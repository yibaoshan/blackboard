设计模式（一）：创建型模式(Creational Pattern)

一、前言

创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。
为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

简单来讲，相较于另外两种类型(结构型和行为型)，创建型模式的侧重点在于如何创建对象

本文会简单介绍几种常见的创建型模式：
1. 单例模式
2. 工厂模式
3. 建造者模式

注意，原型模式不包含在本文中，想要了解更多的可以自行Google
原型模式菜鸟教程：https://www.runoob.com/design-pattern/prototype-pattern.html

二、创建型模式-单例模式

2.1 定义

这里展示uml图

单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。
单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。
除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。
该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。

对于大多数程序员来说，单例模式可能是在众多设计模式中最先掌握的模式之一
由于单例使用简单，同时理解起来也比较容易，所以这里笔者就直接开门见山，介绍一下常见的几种使用方式

2.2 使用

1. 饿汉式
饿汉式
考虑到单例模式的使用场景，笔者认为绝大多数情况下使用饿汉式并不会有浪费内存/降低效率一说
并不用考虑会
毕竟，谁会在单例里面放多余的静态属性/方法呢？

2. 懒汉式-静态内部类
这也是笔者使用最多的一种方式，原因无他，简单方便
3. 懒汉式-DCL
这是较为推荐的一种使用方式，线程安全和懒加载都考虑到了，早期笔者跟着网上教程写单例时都是这种写法
4. 枚举类
比如枚举类不能继承其他类，但是可以实现接口

2.3 单例模式安全：破坏单例
2.4 防止破坏单例

目录：
1. 单例模式
对于枚举，对象的实例会由JVM进行创建，其构造方法由JVM在创建实例的时候进行调用，
基于此，我们可以得知枚举是恶汉类型的单例模式
枚举类能够像普通类一样，拥有字段和方法，枚举类无法被反射破坏，
枚举类使用Javap查看字节码会发现最终被编译成final类并继承于java.lang.Enum

2. 工厂模式
   2.1 简单工厂
   2.2 抽象工厂
   2.3 工厂方法
3. 建造者模式
4. 原型模式

二、单例模式
2.1 介绍
单例模式可能是每个程序员
2.2 uml类图
2.3 使用

三、工厂模式
3.1 模式定义
工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。


引用：
1. https://www.zhihu.com/question/27125796