
第四章：80X86 保护模式及其编程

OS 能够实现特权控制的前提是，CPU 在电路设计侧开发了控制电路。在 8086 中，它是由寄存器 I/OPL 实现的。

先看，先学，因为学着学着，你就会发现，这本书可能不是你想要的。

## 4.1 80X86 系统寄存器和系统指令

80X86 提供了 EFLAGS 标志寄存器和几个系统寄存器，用于控制处理器的运行模式、权限等等，这些都是提供给操作系统的。

操作系统本质也是个大一点的应用程序，所以，也可以说是提供给使用者的，本书里面指的就是 Linux 了。

EFLAGS 包括了几个系统标识，一共有 32 位 bit，看图，黄色是系统标识位，黄色的不知道，灰色的是保留位，看起来好像没用到。

flag 的 1、3、5、12、13、14、15 位在 80X86 CPU 中没有使用，不具有任何含义. 而 0、2、4、6、7、8、9、10、11 位都具有特殊的含义.

这些比特位非常非常非常非常重要，理解它，就能理解当前处理器的运行状态，模式，对后续的 io ，特权级帮助非常大。

- EFLAGS （标志寄存器）

- Memory-Management Registers （内存管理寄存器）

- Control Registers （控制寄存器）

- Debug Registers （调试寄存器）

- Test Registers （测试寄存器）

系统标志寄存器：

- 0，CF，进位标识，Carry Flag。用来反应运算是否产生了进位或者借位，如果运算的最高位产生了进位或借位，CF = 1，否则为 0 
- 1，无名。值为1，干嘛的书里面没说
- 2，PF，奇偶标志，Parity Flag，运算结果中，1 的个数为偶数，PF = 1，否则为 0 。ps，这里图片标错了，标成了恢复标志（RF）
- 3，无名。值为0 ，作用未知
- 4，AF，辅助进位，Assistent Carry Flag。用来反应运算过程中有没有发生进位/借位。CF 是表示结果的最高位，注意区分两者。
- 5，无名。D5 值为 0 ，作用未知。
- 6，ZF，零标志位，Zero Flag，表示计算结果是不是 0 。
- 7，SF，负号标志。表示计算结果是不是负数
- 8，TF，跟踪标志位。置为则进入单步调试模式
- 9，IF，中断标志位。Interrupt Flag，置为 1 处理器才会接收外部中断请求。
- 10，DF，方向标志位，Direct Flag，看不懂。
- 11，OF，溢出标志，Over flow Flag。表示计算结果是否超出当前运算位数的表示范围。
- 12，I/OPL，I/O 特权级标志，I/O Privilege Level
- 13，I/OPL
- 14，NT，嵌套任务标志位，Nested Task，Call、中断、异常时处理器会设置该标志位。？？？啥玩意，看不懂
- 15，空
- 16，RF，恢复标志，Rest Flag，不管
- 17，VM，虚拟 8086 模式标志，Virtual-8086 Mode。置为 1 开启虚拟 8086 模式，否则保护模式。这又是啥，实模式吗？
- 18，以后都是空的

内存管理寄存器：

80X86 提供了 4 个内存管理寄存器：

- GDTR，Global Descriptor Table Register ，全局描述表寄存器，16 位的表长度 + 32 / 64 线性基址
  - 保存 Global Descriptor Table 的基址，32 / 64 bit 位
  - 保存 Table Limit 表限制，16 bit 位
  - 在后面出现的系统指令中，LGDT —— 加载全局描述符表寄存器 (Load GDT Register)
  - SGDT —— 存储全局描述符表寄存器 (Store GDT Register)
- IDTR，Interrupt Descriptor Table Register，中断描述表寄存器
- LDTR，Local Descriptor Table Register，
- TR，Task Register

这几个段基址寄存器用来保存分段机制中的重要的信息表，所以又称保护寄存器

控制寄存器：

CR0、CR1、CR2、CR3，用于控制和确定处理器的工作模式，以及当前任务的特性。它们都是 32 位长度，见图 4.3 ，其中：

- CR0，
  - 第 0 位是 PE 保护位（Protected Enable），复位为 0 时，实地址模式，为 1 时，保护模式。
  - 1~4 位控制协处理器相关，不管。
  - 第 5 位，NE ，Numeric Error，协处理器，数学错误啥的，不管。
  - 第 16 位是 WP 位，写保护 Write Proctect。为 1 时，处理器禁止特权级 0 的程序向，用户级只读页面写入，为 0 时反之。该标志是 UNIX 一类的 OS 创建进程时，实现 "写时复制" Copy on Write 的关键。
  - 第 31 位是 PG 位（Paging），复位为 0 时，关闭分页，为 1 时开启。注意，开启分页要求 PE 和 PG 都置为 1。
- CR1，没用，保留
- CR2，Page-Fault-Linear-Address，为分页服务。记录分页错误的实际物理内存地址
- CR3，Page-Directory- Base，保存在内存中，存放 "页目录表" 的实际地址，缩写 PDBR

在这几个控制寄存器中，CR0 的 PE 保护位用来控制是否开启段内存

不开启的话就是所谓的实模式，用户进程可以根据指针 ++ 找到其他进程的内存地址。

开启的话就是所谓的保护模式，也就是启用内存分段，访问地址的时候需要加一层转换。

CR0 的 PG 位，用来控制是否开启分页，4KB 一页，一般都会启用，我们在各个软件打包都可以看到 4KB 对齐的就是因为这个。

它们俩的组合，想要开启分页 PG = 1，前提是必须启用分段，PE 必须也等于 1 。如果 PE = 0，PG 是什么无所谓，组合无效。

系统指令：

用于管理系统，比如加载系统内存器、管理中断等等

表 4-2 介绍了常用的一些系统指令，自己看

## 4.2 保护模式下的内存管理

对于 80X86 处理器来说，一条指令主要由 "操作码（Opcode）"，和 "操作数（Oprand）" 两部分构成。

操作码是死的，可以查看处理器的操作手册

操作数是活的，它可以在寄存器，也可以在内存里面。

如果要定位在内存里面的数据，就要进行 "内存寻址"，本章要介绍的就是怎么 "寻址"。

前面的 "内存控制寄存器" 中的 CR0 中的 PE（Protected Enable） 位，如果为 1 的话，处理器就会开启分段策略。

启用分段的话，内存就会被分成多个段，那我们访问数据就得加上偏移地址。

为了实现分段功能，8086 提供了 6 个 "段选择符" 的段寄存器：

- CS，Code Segment，代码段寄存器，存放当前正在运行的程序代码所在段的段基址，标识当前使用的指令代码可从该段寄存器指定的存储器段中取得，相应的偏移量由IP提供
- SS，Stack Segment，堆栈段寄存器，存放堆栈的底部地址
- DS，Data Segment，当前程序使用的数据所存放段的最低地址，即存放数据段的段基址
- Es：当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段；
- Fs：标志段寄存器，80386起增加的两个辅助段寄存器之一，在这之前只有es；
- Gs：全局段寄存器

page 88

## 参考资料

- Linux 内存地址映射，https://lrita.github.io/images/posts/memory/Linux_Memory_Address_Mapping.pdf
- Intel 80386 程序员参考手册，https://wizardforcel.gitbooks.io/intel-80386-ref-manual/content/index.html