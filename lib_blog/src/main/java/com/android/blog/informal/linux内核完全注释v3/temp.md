
我们阅读文章 / 书籍时，经常能看到某个功能（比如 MMU ，锁竞争）是硬件实现的，这句话怎么理解呢？

CPU 能够执行分支判断，如果数据不在高速缓存，CPU 还知道去内存中获取，显然它是有一定的执行逻辑的

是因为 CPU 上有应用程序在跑吗？其实不是，CPU 和其他的芯片都是物理电路，在设计之初，就带有这些逻辑

内存中保存的只有两样东西，代码和数据。从 CPU 的角度来说，代码也算是数据的一种，不过为了方便区分，还是分开来看比较好

书上说，段描述符一般由编译器、链接器、加载器和操作系统来创建，但绝不是应用程序。

ps：不是应用程序创建我能理解，但这玩意到底是谁来创建的？

4.3.5 代码和数据段描述符类型，4.3.6 系统描述符类型，看不懂，略过。

4.4 分页机制

分页是 80X86 内存管理机制的第二部分 ，介绍了一页 4KB ，页表等内容

4.5 保护

段级保护，页级保护

书上说，处理器寄存器的 2 个比特位用于记录当前程序的特权级，CPL current privilege level

4.5.1 介绍段级保护，其中的 4.5.1.3 介绍的 "特权级" 有我们经常在网上看到的 0 到 3 的保护环图片

4.5.3.2 介绍了门描述符，调用门、陷进门、中断门等等

4.5.3.4 堆栈切换，每当调用门切换到更高级别代码，CPU 会自动切换到目标代码段的特权级堆栈，

4.5.4 介绍页级保护。

启用分页机制后，CPU 会首先执行段级保护，而后处理页级保护。

- 段优先级高于页，如果发生一个段访问错误，直接抛错，不会抛出页异常
- 如果段被认定只读，分页后，即使页级可读写，写操作依旧会被阻止

## 4.6 中断和异常

80X86 发现一个异常或者收到中断时，会挂起当前程序，并启动异常或中断程序

ps：问如果在 while 1 中断里面发送中断再随机搞点异常呢？

4.6.1 异常，和中断向量

展示了中断向量表，

处理器从两个地方接受中断，硬件和软件

硬件支持是，CPU 芯片有两个引脚 INTR 和 NMI ，两个功能不一样，不管了。

软件支持是，提供操作指令，比如 INT 0x80 会执行 Linux 的系统中断，调用中断0x80。

异常也有两个来源，

- 处理器检测到的程序错误
- 程序主动抛错

程序执行过程中，80X86 提供了故障、陷进和中止三种类型的主动检测

- 故障，Fault，可以被修正，然后还可以继续运行。ps，啥玩意？
- 陷阱，trap，看不懂
- 中止，abort，好理解了，停止

接下来介绍了中断优先级，不管。

## 4.7 任务管理

task 是处理器可以分配调度、执行、挂起的一个单元。

80X86 提供了多任务的硬件支持。ps，怎么提供的？

特权级这块需要重看，CPU 是如何控制的

想法，CPU 的每个核心，在运行进程时，都是独占 CPU 的。当需要切换到牛逼权限执行的时候，通过系统中断，把需要做的事情切换给操作系统去执行，比如发起一个文件 I/O

操作系统完成以后，在拷贝到进程能访问到的内存中，进程内存。

