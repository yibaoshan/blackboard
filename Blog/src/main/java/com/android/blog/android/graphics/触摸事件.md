> - 二，触摸事件的起源（Linux）
>   - 触摸屏驱动捕获原始事件
>     - 信号触发，介绍触摸屏原理
>     - 信号转换，模拟信号转为数字信号
>   - 驱动上报原始事件
>     - Linux input 子系统介绍
>     - 驱动与 Linux kernel 建立通信连接
>     - 建立成功后，驱动上报原始事件
>     - Linux 内核处理/解析事件
> - 三，触摸事件的传递（Android）
>   - 现在触摸数据已经保存在 /dev/input/xxx 文件了，接下来的任务就是读取节点，再封装成不同的事件类型，屏幕坐标，分发给APP
>   - native 层，inputflinger、sf进程
>   - java 层，SystemServer进程
>     - APP事件的分发顺序
>     - viewrootimpl
>       - 这个类在之前的几篇文章中反复出现， activitythread 作为 ams 和 app 之间的沟通的桥梁，viewrootimpl 就是 wms 和 app 的中央枢纽，和 view 相关的发/收消息基本上都在这个类
>       - 那么问题就来了，事件肯定是先到达 view 的，但我们都知道，在实际的开发过程中，activity/dialog 往往最先得到事件，并且还可以拦截掉，不继续向下分发给视图，这是为什么？
> - 四，触摸事件的消费（Application）
>   - 触摸事件到达 View
>     - Activity & Dialog 的拦截
>   - 再回头来看几个 Action 的含义
> - 五，结语
>   - 总结一下从按下屏幕后，事件是怎么传递到我们的应用的？
>   - 首先，触摸屏驱动捕获事件，转交给内核..
>   - 最后，一次完整的 Android 触摸事件的分发流程，大致是这样的
> - 六，参考资料
>
> ### QA
>
> - 触控MCU和触控IC的区别是什么？
>   - 触控IC可以理解为IC只负责输出高或低电平的信号，再给后面的 主MCU做采集处理。
>   - 触控MCU是指MCU内置了touch单元，相当于SOC，无需外挂触控IC，设计，验证参数整体性能时，可以通过调试工具的GUI，直观监测参数调整后的效果。
>   - 而触控IC，则为独立的touch芯片，通常是通过串行接口(例如，I2C、SPI)与主控MCU之间进行通讯实现数据交换，用户需要开发相应的通讯程序，都增加了软件开发的负荷。
> - Linux 主动加载设备驱动

当我们按下屏幕后，事件是怎么传递到应用的？

Android 是一个有用户界面（GUI）的操作系统，在它诞生之初，就是为带有触摸屏的手持设备准备的。因此，触摸屏作为用户的交互方式之一，是必不可少的一部分

本篇是图形系列的第五篇文章，在之前的几篇文章中，我们分别了解了 Android 系统[[渲染/合成的底层原理]](https://juejin.cn/post/7132777622487957517)和[[自定义 View / ViewGroup 的流程]](https://juejin.cn/post/7140332948485570596)；本篇文章我们来聊聊图形系统中，另一个老生常谈的话题：事件分发

今天的文章和以往相比，会稍微有那么一点点不一样 🤏🏻

我们会从认识硬件驱动开始，自底向上，一步步的来了解，事件是怎么到达的系统内核，内核又是怎么传递到应用，以及应用最终是如何消费掉事件的

了解 Android 系统事件分发的流程，对于实际的项目开发有着非常大的帮助

let's go

> *前排提醒：全文近 xxx 字，建议阅读时长 xxx 分钟*

我是概览图

### 一、触摸事件的起源（Linux）

Android Input 事件的类型，和分发的流程都比较复杂，除了触摸事件外，系统还有来自鼠标、键盘、音量键、电源键等其他 Input 设备的事件需要处理

我们日常开发接触比较多的是 ‘触摸事件’，因此，本文主要讨论的是 ‘触摸事件’ 的分发流程（*其他事件路径也差不多*）

本文一共分为三大部分

第一部分介绍 ‘触摸事件的起源’ ，主要讲的是驱动上报原始事件，内核解析原始事件并保存到设备文件中，以供 Framework 读取分发

第二部分介绍 ‘触摸事件的传递’ ，主要讲的是 InputManagerService 怎么把事件传递到应用进程，并分发给目标 Window

第三部分介绍 ‘触摸事件的消费’ ，这是我们应用开发者最熟悉的事件分发/拦截的过程，主要讲的是 ViewGroup / View 的几个关键方法以及使用场景

在文章的开头，我们先来聊聊第一部分的内容，触摸事件的起源

#### 从触摸屏到 CPU

在[《当我们点击“微信”应用后，它是怎么显示出来的？》](https://mp.weixin.qq.com/s/JeGPyknzc0G_TCQNHZD3AQ)这篇文章中，为了搞清楚 Android 设备的绘图硬件是什么，我们拆了一台小米11手机

今天，我们继续来拆小米

![android_graphic_v5_mi10](/Users/bob/Desktop/Bob/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android/graphics/imgs/v5/android_graphic_v5_mi10.png)

*图片来源：[【集微拆评】小米10拆解：内部布局与iPhone相似，1亿像素主摄吸睛](https://www.laoyaoba.com/n/748691)*

如上图，这是拆解后小米10的内部布局，图中左边黄色箭头所指的部分，是触摸屏的触控芯片

米10触控芯片使用的是，来自意法半导体的 "FJABH"，这块芯片是用来干嘛的呢？

用来和 CPU 进行通信的

我是图片

图片来源：https://blog.csdn.net/qq_39797956/article/details/118863217（个人重制版）

我们知道，当我们按下触摸屏后，屏幕的电压/电流大小会发生变化（不展开讨论触摸屏工作原理）

变化的电压/电流会被触控 IC 捕获，接着计算出触摸位置的坐标值，通过 I²C 总线（如上图）发送到主板上的 CPU

[ I²C ](https://elixir.bootlin.com/linux/v4.4.1/source/drivers/i2c)是硬件之间常用的一种通信协议，它规定了什么表示起始、停止、应答和非应答等一系列信号

当然，作为应用开发，我们无需关心他们的通信细节

我们只需要知道： "一旦触摸屏的信号发生变化，触控芯片就能通过 I²C 总线通知到 CPU "。了解这一点就够了

好了，现在触摸信号已经能被 CPU 读取了，接下来我们看 CPU ，也就是操作系统如何处理触摸信号

#### 创建设备文件

我们都知道，Google 使用 Linux 作为 Android 系统的内核，管理着主板上的内存、网卡、硬盘等硬件设备，其中也包括 CPU

在上一小节中，触摸屏已经和 CPU 建立了通信。也就是说，操作系统可以读取触摸屏发送过来的信号了

接下来的工作重点，是制定触摸屏具体的上报规则

我们以键盘事件举例，同样都是按下 'A' 按键

达尔优键盘上报的是：0010

罗技键盘上报的是：0001

同一个按键事件，两个键盘厂商上报的按键值却不相同，这显然是不行的。

所以，只有基本的通信规则（I²C）还不够，我们还需要制定一个内容规则，来规范各个厂家发送的数据内容

说到规范，这就不能不提 Linux 的 Input 子系统了

Linux 在 2001 年发布的 [[2.4.0]](https://elixir.bootlin.com/linux/2.4.0/source/drivers/input) 版本中，首次加入了 Input 子系统的代码，将输入设备的共性抽象出来，当时只有支持手柄、鼠标和键盘。在随后 2002 年发布的 [[2.5.25]](https://elixir.bootlin.com/linux/v2.5.25/source/drivers/input) 版本中，加入了对触摸屏的支持

本质上，这些输入设备还是字符设备，只是套上了 Input 框架。厂商只需要按照 Linux 制定的规范，来上报按键值、屏幕坐标等信息即可

我是图片

如图，Input 子系统分为三层：

- 最下层：输入设备驱动层，drivers/input/xxx，这里就是各大厂商需要遵循的协议规范，向内核层报告输入的内容

- 中间层：输入核心层，input.c 属于这一层。这是 Linux 核心逻辑，用来管理设备添加、卸载等操作，事件提供给应用前的准备工作

- 最上层：输入事件驱动层，到这里硬件驱动已经抽象为设备文件了，对应 /dev/input/xxx ，硬件驱动发送的数据就保存在该路径下的各个设备文件中，等待应用读取

详细的驱动协议，设备的注册过程以及 Linux 处理逻辑，我们这里不展开讨论，太长了

我们只需要了解 Linux 有这么一套框架，并且，设备在开机后，内核系统会根据启动配置去加载各个驱动模块

如果触摸屏驱动化注册成功，我们便可以在 /dev/input/xxx 路径下找到它

我是图片

如图所示，我手里的 Pixel 3 有4个输入设备，从 event0 到 event3

使用 'cat /proc/bus/input/devices' 命令可以查看设备信息，从结果来看，event2 是触摸屏的设备文件，' name = fts ' 表示的触控驱动厂商是 '敦泰'

接着我们用 'getevent' 命令来验证 event2 是不是触摸屏

我是图片

验证结果如上图，当我们滑动屏幕时，终端窗口不停的打印来自 event2 发送的事件消息。这说明，我们的验证结果是正确的， event2 的确是触摸屏文件

好，现在触摸屏的事件已经能被应用程序读取了，我们来简单总结第一部分 ‘触摸事件的起源’ 的内容

首先，按下触摸屏后，触控芯片捕获到电压/电流的变化，计算出位置坐标后，通过 I²C 总线汇报给 CPU

接着，我们需要统一通信内容的规则，在 Linux 平台下，触控芯片需要实现 input.c 协议，事件按照规定的协议上报给内核系统

最后，等到设备开机，内核加载触摸屏驱动，然后是设备的注册/连接/上报的过程

到这里，内核为我们收集好触摸屏的输入事件，并存放在了 eventX 设备文件中，接下来我们看 Android 系统的框架层（Framework）是如何处理触摸事件的

### 触摸事件的传递（Android Framework）

上回书说到，触摸屏上报的事件已经保存到 /dev/input/xxx 设备文件中，那么系统接下来的任务是：

读取触摸事件，并封装成 MotionEvent / KeyEvent 对象，最后分发给正在运行的 APP 使用

读取和分发，是 Android Framework 的主线任务

在接下来的章节中，我们将主要围绕着这两件事展开

> ps：本章节的 '事件分发' 探讨是，如何将触摸事件从设备文件传递到 APP 进程，和 View 的事件分发不是一回事儿，注意别搞混淆了

#### 初识 InputManagerService

为此，我们需要先来了解，Google 为现有的 Framework

本章节主要介绍 Android Framework 层的内容，主要是介绍 InputManagerService（后续简称 IMS）的工作

可见，在 Android Framework 中，核心逻辑可以分为两个部分，触摸事件的读取和触摸事件的分发

这两件事

一来都是业务逻辑，太多了记不过来。二来每次版本升级多少都会有改动，版本之间有差异对 Google 来说非常正常，记得某个版本的实现，意义不大

在 Android Framework 中，inputservice 是负责读取触摸消息的角色

sf 是负责分发事件的角色

看过前两篇的文章或许有疑问，sf不是显示合成的

了解每个类的职责，什么时候通信搞懂几个关键点即可，代码细节可以自己看源码

了解流程为主，简单介绍各个角色的几个关键点

看起来内容并不是很多，但是，framework 还牵扯到 window 体系，几个模块错综复杂

Framework 代码非常复杂，

对错综复杂，为了方便理解，我们先站在程序设计的角度

能够被触摸

我是图片

如图，

ims 必须依赖这些底层组件，才能优雅的实现事件的读取与分发

下文 ims 指的是 input，wms 指的是 window，sf 指的是 surface，大致的启动流程：先启动 native 进程（sf），再启动 java 进程（）

let's go

#### 打个招呼

我们都知道，InputManagerService 作为输入设备的枢纽，在系统中起到承上启下的衔接作用。但是，IMS 也不是直接读取，完成读取/分发的另有其人

接下来，我们将一起来认识

EventHub

文件在frameworks/native/services/inputflinger/EventHub.cpp

它的作用是监听、读取/dev/input目录下产生的新事件，并封装成RawEvent结构体供InputReader使用。

InputReader
文件在frameworks/native/services/inputflinger/InputReader.cpp

InputReader运行在一个单独的进程中，这个进程由InputManagerService的初始化而新建，具体内容请见：

#### 启动过程

### 总结

这篇文章比较长，上下的跨度也比较大。其中，硬件驱动和系统内核这两块都不是我擅长的领域，因此，各位大佬如果发现本文有写的不对的地方，还望及时指出，我会第一时间改正，感谢

欢迎各位大佬留言探讨技术问题

全文完

### 参考资料

从上到下顺序为：触摸屏原理、I2C总线原理、Input 子系统框架、Framework 框架、应用层 APP

- I2C总线 & Drivers & Linux Input 子系统
- [电阻屏已经被智能手机抛弃，还有哪些应用场景？](https://rohm.eefocus.com/article/id-317)
- [手机全贴合屏幕技术解析](https://blog.csdn.net/weixin_51554164/article/details/124965131)
- [【Linux驱动】I2C子系统与触摸屏驱动 - @hongZ](https://blog.csdn.net/qq_39797956/article/details/118863217)
- [【Linux驱动】input子系统与按键驱动 - @hongZ](https://blog.csdn.net/qq_39797956/article/details/117898095)
- [Linux驱动开发|input子系统 - 安迪西](https://blog.csdn.net/Chuangke_Andy/article/details/122181549)
- [Linux驱动开发|电容触摸屏 - 安迪西](https://blog.csdn.net/Chuangke_Andy/article/details/122454299)
- [Linux裸机开发|电容触摸屏实验 - 安迪西](https://blog.csdn.net/Chuangke_Andy/article/details/120935263)
- [从 0 开始学 Linux 驱动开发 - Hcamael](https://paper.seebug.org/779/)
- [Android(Linux) 输入子系统解析 - Andy Lee](http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/)
- [Android 如何上报 Touchevent 给应用层 - 董刚](https://dqdongg.com/c/touch/android/2014/07/10/Touch-inputevent.html)
- Android Framework
- [Android 输入子系统1：IMS 初始化与启动 - 李斌](https://sleticalboy.github.io/android/2021/01/22/android-input-subsystem-1/)
- [这一次，带你彻底弄懂 Android 事件分发机制(外/内层责任链) - 伤心的猪大肠](https://juejin.cn/post/6925336861137174541)
