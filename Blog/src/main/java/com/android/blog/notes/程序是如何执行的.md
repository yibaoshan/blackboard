

### 并发和并行

#### 并发

当有多个线程在操作时，如果系统只有一个 CPU，则根本不可能真正同时进行一个以上的线程

CPU 只能分成若干个时间段，再将时间段分配给各个线程执行

在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。

#### 并行

当系统有一个以上 CPU 时，则线程的操作有可能非并发。

当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行(Parallel)。

#### 多核 CPU 和多 CPU 架构

两者的主要区别在于，多核 CPU 只有一套 '内存管理单元' 和 '高速缓存'，而多 CPU ，每块 CPU 都配有单独专属的 MMU 和 Cache

对于多核心的架构，需要共用一套 MMU 和 Cache，所以地址空间是一个，同一时刻只能运行一个进程，多个线程

对于多 CPU 架构来说，因为每个 CPU 都有单独的 MMU 、Cache，所以每个 CPU 都支持运行进程，多个 CPU 自然可以并行多进程了

#### as-if-serial 规则

不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。

编译器、runtime和处理器都必须遵守as-if-serial语义。

为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果

#### 指令重排

as-if-serial 规则的产物，所谓编译器重排，指的是在生成目标代码的过程中，可能会发生交换前后没有依赖关系的内存访问顺序的行为，比如

``` java
int a = a1;
double b = b1;
```

编译器不保证在最终生成的 class 代码中，对 a 内存的写入在对 b1 内存的读取之前，并且，整形和浮点型用的运算器不同，还是可能被重排的

#### happens-before 规则

#### 内存可见性

MESI协议和NUMA架构

### 参考资料

- [关于指令重排序 - V2EX](https://v2ex.com/t/746080)
- [4个你未必知道的内存小知识 MESI协议&NUMA架构](http://www.broadview.com.cn/article/347)