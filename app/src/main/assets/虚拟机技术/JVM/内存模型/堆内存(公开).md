### Overview
1. 内存划分
    1.1. 年轻代
    1.2. 老年代
    1.3. 元空间(JDK1.8 之前叫永久代)
2. 内存大小设置和OOM
3. 对象在堆中的生命周期
4. 对象的分配过程
5. TLAB
6. 常见问题(逃逸分析)

### 一、内存划分
1. 年轻代：新分配的和没到年龄的都在年轻代区
年轻一代被分为三个部分——伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称为 from/to 或 s0/s1），默认比例是8:1:1
年轻代内部的GC逻辑是：
- 大多数新创建的对象都位于 Eden 内存空间中
- 当 Eden 空间被对象填充时，执行 Minor GC，并将所有幸存者对象移动到一个幸存者空间中
- Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的
- 经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代

2. 老年代：被长时间使用的对象
- 老年代出发GC时机通常是该区域满了的时候
- 大对象直接进入老年代，避免在年轻代的Eden区和Survivor区复制来复制去

3. 元空间：

### 二、内存大小设置和OOM

- -Xms 用来表示堆的起始内存，等价于 -XX:InitialHeapSize，默认情况下为：电脑内存大小 / 64
- -Xmx 用来表示堆的最大内存，等价于 -XX:MaxHeapSize，默认情况下为：电脑内存大小 / 4

### 三、对象在堆中的生命周期

1. 在Eden空间不足启动GC，存活对象挪到Survivor区，年龄+1，同时，在Survivor也会发生GC，存活对象年龄同样+1
2. 分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代

### 四、对象的分配过程

- 优先放在Eden区

#### 五、TLAB
什么是 TLAB （Thread Local Allocation Buffer）?

### 六、常见问题

- 为什么堆内存要划分老年代和年轻代
答：减轻GC负担，优化GC性能

- 什么是逃逸分析？
首先要清除什么是逃逸：在方法内声明一个对象，是在方法内使用，没有逃逸，返回给其他方法使用了，则被称为发生逃逸
发生逃逸之后编译器可以做以下优化：1栈上分配，2同步省略(也叫锁消除)，3分离对象或标量替换


