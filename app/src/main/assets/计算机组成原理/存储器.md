
### 概述

内存的本质是存储器，让计算机拥有记忆功能，一般分为两个大类

- ROM（Read Only Memory）：断电数据不消失，用于存储资料
- RAM（Random Access Memory）：随机存储器，断电数据消失，常见的如内存

FLASH 、磁盘、光盘都是 ROM ，

而 RAM 则又分为两类，静态存储（Static RAM/SRAM）和动态存储（Dynamic RAM/DRAM），前者用在 CPU 的一二级缓存比价多，后者的特性是需要定时刷新

### 内存分类

- 寄存器：组成 CPU 的时序电路成员之一，和运算器/控制器共用一个晶振，同时钟同频，频率高速度快。正因为要保证够快，所以寄存器容量不能做大，做大了用到晶体管变多，面积变大，查找速度跟不上，主频就跟不上
- 高速缓存：同样继承在 CPU 电路中，比 CPU 主频低，一次读写可能差几个时钟周期，添加的原因之一是访问内存太慢了，L1、2、3级访问延迟依次变长，同时容量也依次更大
- 内存：随机存储器，1~64 GB不等，频率比高速高速缓存都低很多
- 磁盘：存储器，机械 or 固态

## 内存组成原理

内存由矩形排列的 cell 组成，每个 cell 由一个电容和一个晶体管构成，由于电容会漏电，所以内存需要过段时间刷新一下，知道数据改变或断电

## CPU 高速缓存

### 什么是高速缓存

CPU 高速缓存机制的引入，主要是为了解决 CPU 越来越快，相比之下主存的速度越来越慢的矛盾

引入高速缓存后，CPU 在需要访问主存中某一地址空间时，高速缓存会拦截所有对于内存的访问，并判断所需数据是否已经存在于高速缓存中

如果缓存命中，则直接将高速缓存中的数据交给 CPU；如果缓存未命中，则进行常规的主存访问

获取数据交给 CPU 的同时也将数据存入高速缓存，如果高速缓存满了，则利用 LRU 或者 LFU 算法清理

LRU（Least Recently Used），根据使用时间排序，时间靠前的表明刚被使用过

LFU（Least Frequently Used），根据使用次数排序，次数越多越不容易被清理


### 多核 CPU 之间的"缓存一致性"问题


在多核CPU的架构下，通常每一个核心都拥有着自己独有的高速缓存

多核并发的修改其高速缓存中同一内存的映射数据就会出现高速缓存中的数据不一致的问题，必须对多核CPU下的高速缓存并发访问施加一定的约束


## MESI 高速缓存一致性协议

Modified:

　　缓存数据有效，在读入缓存后曾经被当前CPU修改过却没有写回，导致与内存中的对应数据不一致。

　　内存中对应的数据只在本地核心的高速缓存中存在，其它核的高速缓存中并没有缓存这一内存数据。

　　有效，本地cache独占，与内存数据不一致(被修改 Modified)。

Exclusive:

　　缓存数据有效，在读入缓存后没有被当前CPU修改过，与内存中的对应数据保持一致。

　　内存中对应的数据只在本地核心的高速缓存中存在，其它核的高速缓存中并没有缓存这一内存数据。

　　有效，本地cache独占，与内存数据一致(被独占 Exclusive)。

Shared:

　　缓存数据有效，在读入缓存后没有被当前CPU修改过，与内存中的对应数据保持一致。

　　内存中对应的数据除了本地核心的高速缓存中存在，其它核的高速缓存中也缓存了这一内存数据。

　　有效，与其它cache共享，与内存数据一致(被共享 Shared)。

Invalid:

　　缓存数据无效。无效的含义既代表着之前缓存行有效，却因为某些事件变为无效；也代表着对应缓存行不存在。

　　上述缓存行的共享/独占状态，指的是本地高速缓存中存在有效的对应存储单元缓存行，而其它核的高速缓存中不存在对应单元的内容或是对应的缓存行是Invalid无效状态。

　　在MESI协议中不存在与Invalid无效可以视作是等价的。


## 参考资料


- [高速缓存一致性协议MESI与内存屏障](https://www.cnblogs.com/xiaoxiongcanguan/p/13184801.html)