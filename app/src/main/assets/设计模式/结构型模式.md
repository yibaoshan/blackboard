
结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木

- **类结构型模式：关心类的组合**
  - 由多个类可以组合成一个更大的系统
  - 一般只存在继承关系和接口实现关系
- **对象结构型模式：关心类与对象的组合**
  - 在一个类中定义另一个类的实例对象，通过该对象调用其方法
  - 用 "关联关系" 来替代 "继承关系"，符合 “合成复用原则”

## 享元模式

享元模式的设计思想是通过复用对象，以达到节省内存的目的

参考需要缓冲池的场景，例如 ：

- **Android Message 对象**
- **Java 基本类型的包装类**

## 代理模式

代理模式是指在不改版原始类的情况下，通过新增代理类的方式，来给原始类加入新的功能

常用在业务系统中开发一些 **"非功能性需求"**，比如：监控、统计、日志。

我们将这些 **"附加功能"** 与 **"业务功能"** 解耦，放到 "**代理类**" 统一处理，让开发人员只需要关注业务方面的开发。

除此之外，代理模式在 "**跨进程通信**"、"**插件化**" 等场景中也有使用

以统计方法耗时举例：

- **外部类实现** ：通常是在原始类无法进行更改的情况使用，比如第三方库
  - 创建 **Proxy** 类，继承自三方库，再统计耗时
- **内部类实现** ：原始类是自己人，代码可以修改。那么抽象出统一的接口
  - 实现类 和 代理类 都实现该接口
  - 实现类里面，写业务逻辑
  - 代理类里面，写统计方法耗时

注意，代理模式在 **不改变原始类接口的条件下，为原始类定义一个代理类**

主要目的是 **控制访问**，而非 **加强功能**，这是它跟 **装饰器模式** 最大的不同。

## 装饰者模式

装饰模式 是指在不改变原始类的情况下，通过新增 "**装饰类**" 的方式，加强原始类的属性。

参考 Android 中的： **ContextWrapper** 和 **ContextImpl** 都是 **Context** 的实现类

## 适配器模式

适配器模式可以简单理解成 "**转换器**" ，大部分情况下是作为一种 "**补偿机制**"，用来补救设计上的缺陷

如果在设计初期，我们就能协调规避掉 "**接口不兼容**" 的问题，那这种模式就没有应用的机会了

**举个例子** ：

假设项目中集成了 "**阿里支付SDK**"，在调用登录方法时需要传入 "**高德地图**" 提供的 "**位置信息**"

但项目早期已经接入 "**腾讯地图**"，"**腾讯地图**" 能够提供 "**阿里支付**" 所需的 "**位置信息**"，只是入参类型不同接口不兼容。

这种场景我们就可以使用 "**适配器模式**"

定义一个包装类，把 "**腾讯地图**" 提供的 "**位置信息**" 转换成 "**阿里支付**" 需要的类型，这个包装类指的就是 **"适配器(Adapter)"**

## 参考资料

- [从Android源码角度谈设计模式（二）：结构型模式](https://juejin.cn/post/7051139976095858725)