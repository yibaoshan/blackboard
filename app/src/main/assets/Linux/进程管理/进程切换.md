
Linux 中使用 "**task_struct**" 的结构来描述调度的一个单元，不分进程和线程。

对于那些进程拥有的公共资源，比如地址空间、打开的文件、信号等，Linux 分别使用相应的对象（结构体）来描述它们，例如描述进程地址空间的 mm_struct

每一个线程都保存有自己的 "**寄存器**" 以及 "**线程栈**" 等数据

也就是说，**某一刻某一个处理器上各个寄存器的值来自于一个线程**

在线程被切换出去时这些寄存器信息都会被保存回线程

而被调入的线程所保存的寄存器信息将被载入

## 进程切换的函数调用

```
context_switch  // kernel/sched/core.c
->switch_mm_irqs_off
  ->switch_mm
  ->__switch_mm
    ->check_and_switch_context
    ->cpu_switch_mm
      ->cpu_do_switch_mm(virt_to_phys(pgd),mm) //arch/arm64/include/asm/mmu_context.h
    
```

## 创建进程/线程开销

在 linux 中，创建进程或线程本质上都是在内核空间建立一个 "**task_struct**" 结构，但着不意味着进程、线程拥有同样的开销。

创建线程只需要和当前的 task_struct 共享资源即可；

而创建进程时，不仅要建立一个task_struct结构，还需要复制当前 task_struct 的公共资源。

虽然 linux 有写时复制的机制，但这只是延后复制，而非不复制，债是要还的，晚一些也是要还的。因此就创建方面来说，进程的开销大于线程的开销。

## 切换进程/线程开销

linux 切换的都是 "**task_struct**"，但被换出的 "**task_struct**" 和换入的 "**task_struct**" 是否共享公共资源，这对切换的开销有不小的影响。

假如两者不共享公共资源（进程切换），那么当前 core 的 "**Cache**" 和 **TLB** 都会失效（有歧义，现在的CPU在进程切换的时候不需要失效 Cache 和 TLB 的（因为PIPT映射机制以及地址空间ID））

换入的进程在运行初期，"**Cache**" 和 "**TLB**" 尚未有效建立时，运行会比较慢。

而有效建立 "**Cache**" 和 "**TLB**" 是需要时间的，考虑到调度往往以毫秒为单位，因此这个时间是无法忽略的。

假如两者共享公共资源（线程切换），这就意味着两者共享虚拟地址空间，也就无需失效 Cache 和 TLB。

当然，考虑到两个线程运行的指令、访问的数据可能会有部分位于不同的地址处

因此换入的线程在运行初期，可能会有较多的 Cache 和 TLB 未命中，但这比起进程切换需要失效 Cache 和 TLB 要好得多

所以，就切换方面来说，**进程的开销大于线程的开销。**

## 从内存角度看进程切换

围绕着虚拟内存管理（Virtual Memory Management）技术，就产生了分页技术，虚拟地址，地址空间，TLB，MMU等概念

虚拟内存管理技术中最常见的是分页（paging）技术，MMU就是该技术的硬件实现

虚拟地址空间划分成称为页（page）的单位，而相应的物理地址空间也被进行划分

主存是由 MMU 来管理的，操作系统有多级分页

对于OS来说，页表是进程私有的，因此各个进程的页表被放置在不同的物理内存中。

在进程启动或者切换时，都必须把进程的页表的起始物理地址告诉MMU，也就是上面提到的 TTB 值

