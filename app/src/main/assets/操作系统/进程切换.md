
Linux 中使用 task_struct 的结构来描述调度的一个单元，不分进程和线程。

对于那些进程拥有的公共资源，比如地址空间、打开的文件、信号等，Linux 分别使用相应的对象（结构体）来描述它们，例如描述进程地址空间的 mm_struct

### 进程创建

在linux中，创建进程或线程本质上都是在内核空间建立一个 task_struct 结构，但着不意味着进程、线程拥有同样的开销。

创建线程只需要和当前的 task_struct 共享资源即可；而创建进程时，不仅要建立一个task_struct结构，还需要复制当前task_struct的公共资源。

虽然linux有写时复制的机制，但这只是延后复制，而非不复制，债是要还的，晚一些也是要还的。因此就创建方面来说，进程的开销大于线程的开销。

### 从线程角度

每一个线程都保存有自己的寄存器以及线程栈等数据

也就是说，某一刻某一个处理器上各个寄存器的值来自于一个线程

在线程被切换出去时这些寄存器信息都会被保存回线程

而被调入的线程所保存的寄存器信息将被载入

### 从进程角度

linux 切换的都是 task_struct，但被换出的 task_struct 和换入的 task_struct 是否共享公共资源，这对切换的开销有不小的影响。

假如两者不共享公共资源（进程切换），那么当前core的Cache和TLB都会失效（有歧义，现在的CPU在进程切换的时候不需要失效Cache和TLB的（因为PIPT映射机制以及地址空间ID））

换入的进程在运行初期，Cache和TLB尚未有效建立时，运行会比较慢。

而有效建立Cache和TLB是需要时间的，考虑到调度往往以毫秒为单位，因此这个时间是无法忽略的。

假如两者共享公共资源（线程切换），这就意味着两者共享虚拟地址空间，也就无需失效Cache和TLB。

当然，考虑到两个线程运行的指令、访问的数据可能会有部分位于不同的地址处

因此换入的线程在运行初期，可能会有较多的Cache和TLB未命中，但这比起进程切换需要失效Cache和TLB要好得多

所以，就切换方面来说，进程的开销大于线程的开销。

### 从内存角度

围绕着虚拟内存管理（Virtual Memory Management）技术，就产生了分页技术，虚拟地址，地址空间，TLB，MMU等概念

虚拟内存管理技术中最常见的是分页（paging）技术，MMU就是该技术的硬件实现

虚拟地址空间划分成称为页（page）的单位，而相应的物理地址空间也被进行划分

主存是由 MMU 来管理的，操作系统有多级分页

对于OS来说，页表是进程私有的，因此各个进程的页表被放置在不同的物理内存中。

在进程启动或者切换时，都必须把进程的页表的起始物理地址告诉MMU，也就是上面提到的TTB值