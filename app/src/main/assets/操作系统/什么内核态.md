

### 对 CPU 来说



应用程序 = 用户态 = CPU 处于普通模式下，此时，无法执行特权模式的指令

操作系统 = 内核态 = CPU 处于特权模式下

一旦操作系统选择把 CPU 的工作模式，切换为普通模式，再想切换回特权模式

如果不加以管制，任意用户程序代码在执行时，可能会进行非法操作，随意更改内存值，读取不属于网卡信息。因此，必须做限制

通过硬件手段（也只能硬件手段才能做到），限制某些代码，使其无法控制整个物理硬件，进而使各个不同用户，不同任务的代码，无权修改整个物理硬件，再进而保护操作系统的核心底层代码和其他用户的数据不被无意或者有意地破坏和盗取。

切换 CPU 工作模式只是一条普通的指令，那应用程序可以调用吗？

或者说，为什么只有操作系统可以执行这条指令？

sysenter，sysexit

用户程序只能通过操作系统提供的接口，来执行 I/O 等限制操作。

而操作系统提供的接口，里面就包含了切换 CPU 工作模式的指令。

闲聊，什么是内核态？

首先，我们要知道，CPU 和操作系统相辅相成的关系

首先，我们要知道 CPU 有好几种运行模式，比如 X86 有4种，ARM 有 7种

为了方面理解，我们先把 CPU 简单的分为普通模式，和特权模式

特权模式和普通模式的区别在于，内存、I/O、多了一些特权指令

普通模式和特权模式，支持的指令是不同的，或者说，同一条指令，运行产生的结果不同。

如果在普通模式下，不小心执行了特权模式的指令，CPU 会抛出异常中断。因为在 取指、译指 阶段会对指令的级别做校验

假设我们的环境是：CPU + 单一程序（类比单片机）

那么，这个程序想要用 CPU 的哪种模式都可以，自己爱怎么切换怎么切换

这时候，CPU 有没有工作模式，对应用程序来说是无所谓的，我的地盘我做主啊

但是，如果我们的环境是：CPU + 操作系统，那问题就来了

CPU 本身只会取指执行，切换 CPU 的工作模式同样是指令，那么，不只是操作系统可以用这条指令，其他程序也可以

而一旦应用程序可以任意切换 CPU 的工作模式，那 CPU 硬件设计的工作模式就没有意义了。甚至，应用程序还可以抢占操作系统，把自己变为操作系统中的操作系统

这就像在 Android 的 Loop 中，loop 执行了一个死循环 runnable ，这个死循环同样在获取消息队列中的消息，然后分发

因此，操作系统必须想发设法的来保证，应用程序只能通过跳转到操作系统代码的方式，来切换到内核态上，这样也就间接保障了内核态下执行的都是操作系统（包括驱动）的代码。

### 对内存来说

CPU 部分讲完了，我们接着来看内存的权限管理

和 CPU 不同，操作系统 和 应用程序 读 / 写内存 的指令是一样的，但是，某一块内存地址

