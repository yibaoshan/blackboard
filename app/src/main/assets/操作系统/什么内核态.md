

### 对 CPU 来说

首先，我们要知道 CPU 有好几种运行模式，比如 X86 有4种，ARM 有 7种

为了方面理解，我们先把 CPU 简单的分为普通模式，和特权模式

特权模式和普通模式的区别在于，内存、I/O、一些指令

普通模式和特权模式，支持的指令是不同的，或者说，同一条指令，运行产生的结果不同。

如果在普通模式下，不小心执行了特权模式的指令，CPU 会抛出异常中断。因为在 取指、译指 阶段会对指令的级别做校验

假设我们的环境是：CPU + 单一程序（类比单片机）

那么，这个程序想要用 CPU 的哪种模式都可以，自己爱怎么切换怎么切换

这时候，CPU 有没有工作模式，对应用程序来说是无所谓的，我的地盘我做主啊

但是，如果我们的环境是：CPU + 操作系统，那问题就来了

CPU 本身只会取指执行，切换 CPU 的工作模式同样是指令，那么，不只是操作系统可以用这条指令，其他程序也可以

而一旦应用程序可以任意切换 CPU 的工作模式，那 CPU 硬件设计的工作模式就没有意义了。甚至，应用程序还可以抢占操作系统，把自己变为操作系统中的操作系统

这就像在 Android 的 Loop 中，loop 执行了一个死循环 runnable ，这个死循环同样在获取消息队列中的消息，然后分发

因此，操作系统必须想发设法的来保证，应用程序只能通过跳转到操作系统代码的方式，来切换到内核态上，这样也就间接保障了内核态下执行的都是操作系统（包括驱动）的代码。

### 对内存来说

CPU 部分讲完了，我们接着来看内存的权限管理

和 CPU 不同，操作系统 和 应用程序 读 / 写内存 的指令是一样的，但是，某一块内存地址

