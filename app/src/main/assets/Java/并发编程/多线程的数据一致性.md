
MESI 解决的是多核情况下，"**高速缓存**" 和 "**主存**" 之间的数据一致性问题

```
 CPU A、B，对应的 cache a 和 cache b 对于 主存 x 的数据一致性
```

volatile 解决的是，"线程" 和 "线程" 之间的数据一致性问题

```
 thread A、B，对于 主存 x 的数据一致性
 即使在单核 CPU 中，也需要 volatile 来同步状态，例如：
 
 thread A 修改了数据，thread B 使用时，即使已经读过了，也要重新获取
```

后者依赖前者，但是不能说前者就完全解决了后者的问题

因为如果仅保证高速缓存的一致性，工作内存不失效的话那么依然存在可见性问题

不管有没有发生指令重排，对操作系统来说，都需要提供某种机制来保证：

**多线程环境下，数据一致性的问题，即使是单核 CPU**

举个例子