
## 多线程之间的数据一致性

举例：**单核 CPU ，共享变量 x = 0，两个线程 thread A 、B**

### 读数据

```
 thread A 读数据 load x 到线程栈 a1
 CPU 切换
```

MESI 解决的是多核情况下，"**高速缓存**" 和 "**主存**" 之间的数据一致性问题

```
 CPU A、B，对应的 cache a 和 cache b 对于 主存 x 的数据一致性
 （因为每个核的私有高速缓存都有一份）
```

volatile 解决的是，"**线程**" 和 "**线程**" 之间的数据一致性问题

```
 thread A、B，对于 主存 x 的数据一致性
 （因为每个线程的线程栈都有一份数据）
 
 因此，即使在单核 CPU 中，也需要 volatile 来同步状态，例如：
 
 volatile 保证的是，假设 thread A 修改了数据，那么 thread B 使用时，即使已经读过了，也要重新获取
```

基于以上，不管有没有发生指令重排，对 jvm 来说，都需要保证：

**多线程环境下，数据一致性的问题，即使是单核 CPU**

## volatile 关键字

volatile 的意思是，在 Java 内存模型中，确保所有线程看到的由 volatile 修饰的共享变量的值是一致的

因此，volatile 至少要解决两个层面的问题

- 多 CPU 情况下，thread A 写入数据后，要立即写入主存，以此来让其他核的缓存行失效，这点由 mesi 保证
- 多线程情况下，thread A 写入数据后，其他线程的线程栈中的数据失效。如何实现的不清楚，暂时理解为，其他线程每次用到共享变量时，需要重新读取

第一个问题，由 CPU 的 MESI 协议，和 "**内存屏障指令**" 来保证

第二个问题，不清楚