### Overview
1. 方法区介绍
2. 方法区的内部结构(类型信息、域(Field)信息、方法(method)信息)
3. 常量池
4. 方法区在Java 6、7、8的演进细节
5. 方法区的垃圾回收
6. 常见问题

### 一、方法区介绍

哪些东西放在方法区呢？
- 静态变量
- 类的信息、方法的信息、域(Field)的信息
- 常量池

- 类加载到内存指的即是方法区，方法区常量池里面保存着类的信息
- 方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误
- JVM 关闭后方法区即被释放

### 二、方法区的内部结构

栈、堆、方法区的交互关系

```
Person p = new Person();

Person->方法区
p->虚拟机栈
new Person()->堆

```

### 三、常量池

- 字节码文件加载之后，文件常量池constant_pool(简称cp_info)里面的值被加载到内存，这一块内存就是常量池
- JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的

### 四、方法区在Java6、7、8中的演进细节

Java7时：
- 字符串常量池(interned strings)转移到了Java Heap
- 类的静态变量(class statics)转移到了Java Heap

永久代在Java8被元空间取代

### 五、方法区的垃圾回收

判定一个类型是否属于 “不再被使用的类”，需要同时满足三个条件：
1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例
2. 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

简单来说，就是该类被卸载

- 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。