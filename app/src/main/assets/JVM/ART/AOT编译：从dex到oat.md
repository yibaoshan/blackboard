
虽然 Dalvik 已经被 ART 取代，但其中的 Dalvik 字节码格式还是被保留了下来。

即便在最新版本的 Android 中，编译 Java 生成的依旧是 DEX 文件

- APK 在安装的时候，打包在里面的 classes.dex 文件会被工具 dex2oat 翻译成本地机器指令，最终得到一个 ELF 格式的 oat 文件。

- APK 运行时，上述生成的 oat 文件会被加载到内存中，并且 ART 虚拟机可以通过里面的 oatdata 和 oatexec 段找到任意一个类的方法对应的本地机器指令来执行。

在 Android 7.0 中，Google又为Android添加了即时 (JIT) 编译器。

JIT和AOT的配合，是取两者之长，避两者之短：在APK安装时，并不是一次性将所有代码全部编译成机器码。

而是在实际运行过程中，对代码进行分析，将热点代码编译成机器码，让它可以在应用运行时持续提升 Android 应用的性能。

**Ahead-of-time**（AOT）是相对于 **Just-in-time**（JIT）而言的。

**JIT** 是在运行时进行 "**字节码**" 到 "**本地机器码**" 的编译，这也是为什么 Java 普遍被认为效率比 C++ 差的原因。

无论是解释器的解释还是运行过程中即时编译，都比 C++ 编译出的 "**本地机器码**" 执行多了一个耗费时间的过程。

而 **AOT** 就是向 C++ 编译过程靠拢的一项技术：

当 APK 在安装的时候，系统会通过一个名称为 **dex2oat** 的工具将 APK 中的 "**dex文件**" 编译成包含 "**本地机器码**" 的 "**oat文件**" 存放下来。

这样做之后，在程序执行的时候，就可以直接使用已经编译好的机器码以加快效率。

## APK 安装 ：ART VS. Dalvik

### 1、Dalvik

在 **Dalvik** 虚拟机上，APK 中的 "**Dex文件**" 在安装时会被优化成： "**odex文件**"

在运行时，会被 "**JIT 编译器**" 编译成 CPU 本地代码。

### 2、ART

而在 **ART** 虚拟机上，"**Dex 文件**" 会直接由 "**dex2oat**" 工具翻译成 "**oat 文件**"

由于 32 位和 64 位的机器码有所区别，**oat文件** 位于设备的：

- **/data/dalvik-cache/arm/**
- **/data/dalvik-cache/arm64/**

"**oat 文件**" 中既包含了 **dex文件** 中原先的内容，也包含了已经编译好的 "**本地代码**"

## OAT 文件

OAT 文件 遵循 ELF 格式。

ELF 是 Unix 系统上可执行文件，目标文件，共享库和 Core dump 文件的标准格式。

全称是 Executable and Linkable Format 该文件格式如下图所示：



