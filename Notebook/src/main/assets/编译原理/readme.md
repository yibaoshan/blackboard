
编译原理入门即可，非重点

### 编译器和解释器

首先，要明确一个概念，编译与解释描述的是程序的执行方式，与语言无关

并且，程序的编译与解释并没有太大的区别，判断的依据是，源文件是在什么时候被翻译成目标 CPU（指令集） 的指令

#### 编译

编译，指的是编译器会将源文件预先处理成目标文件，这个目标文件可能是汇编/机器语言，但也可能是其他语言。比如，Java 源文件编译后就是 class 字节码

对 C 语言或者其他编译型语言来说，编译生成了目标文件，而这个目标文件是针对特定的 CPU 体系的

为 ARM 生成的目标文件，就不能被用于 MIPS 的 CPU，如果这个程序需要在另外一种 CPU 上面运行，这段代码就必须重新编译

#### 解释

解释，指的是边处理源文件，边执行

对于各种非编译型语言（例如python/java）来说，同样也可能存在某种编译过程，但他们编译生成的通常是一种『平台无关』的中间代码，比如 class 字节码

这种代码一般不是针对特定的 CPU 平台，他们是在运行过程中，才被翻译成目标 CPU 指令的

因而，在 ARM CPU 上能执行，换到 MIPS 也能执行，换到 X86 也能执行，不需要重新对源代码进行编译。


### 编译过程

#### 指令重排

所谓编译器重排，指的是在生成目标代码的过程中，可能会发生交换前后没有依赖关系的内存访问顺序的行为，比如

``` java
int a = a1;
int b = b1;
```

编译器不保证在最终生成的 class 代码中，对 a 内存的写入在对 b1 内存的读取之前

如果上面两行代码的顺序，是有要求的，比如 b1 可能在其他线程中和 a1 有关联，那么我们就需要用一些手段来保证编译器不会进行错误的优化，方案有三

- 把对应的变量声明为 volatile 的，C++ 标准保证对 volatile 变量间的访问编译器不会进行重排，不过仅仅是 volatile 变量之间， volatile 变量和其他变量间还是有可能会重排的；
- 在需要的地方手动添加合适的 Memory Barrier 指令，Memory Barrier 指令的语义保证了编译器不会进行错误的重排操作；
- 把对应变量声明为 atomic 的， 与 volatile 类似，C++ 标准也保证 atomic 变量间的访问编译器不会进行重排。不过 C++ 中不存在所谓的 “atomic pointer” 这种东西，如果需要对某个确定的地址进行 atomic 操作，需要靠一些技巧性的手段来实现，比如在那个地址上进行 placement new 操作强制生成一个 atomic 等；

### 参考资料

- [C++ 中的 volatile，atomic 及 memory barrier](https://gaomf.cn/2020/09/11/Cpp_Volatile_Atomic_Memory_barrier/)
