

### 51 单片机的组成


CPU 由运算器 + 控制器 + 各种寄存器组成 ，我们这里是把 CPU 的电路也拆分开来介绍


- 寄存器 ：简单理解为特殊功能的、容量更小的 RAM ，51单片机有21个工作寄存器，用来暂存数据和状态
- 
- 运算器 ：由加减乘除、与或非逻辑判断这样的运算单元（ALU）和一些寄存器组成，了解 ALU 运算单元和 ACC 累加寄存器就行了
  - 算术逻辑运算单元（ALU）：加减乘除、逻辑判断
  - 累加寄存器（ACC）：临时存放运算的结果
  - 还有些不知道干嘛的寄存器：B 寄存器、暂存寄存器 TEMP1、TEMP2、程序状态寄存器 PSW
- 
- 控制器 ：由指令寄存器，指令译码器等组成，负责从ROM存储器取指令，解析后丢给运算器，或者去控制某个IO
  - 程序计数寄存器（PC） ：保存执行指令的地址
  - 指令寄存器（IR） ：存放取出来的指令？有疑问
  - 指令译码器（ID） ：从名字可以看出来是解码，作用待查
  - 还有些不知道干嘛的寄存器：堆栈指针（SP）、数据指针（DPTR）


- ROM：存储器，编译完的的二进制代码保存在这里，静态变量固定值也在这，大小有限制，我买的51单片机存储器只有4k字节
- RAM：内存，大小为128字节
- 总线：电路板自身就是总线，上述所有元器件都通过电路板的电路连接在一起


### 需求分析

现在我们面前有块使用了 51单片机 的开发板，板子上有几个 LED 发光二极管，一个蜂鸣器，和其他外围设备

我们想让：

- 板子上的灯一起亮起来，同时蜂鸣器开始发声
- 维持 1s 后，关闭灯和蜂鸣器
- 灯和蜂鸣器关闭以后，啥都不做，等待 1s
- 1s 过后，再次亮灯，蜂鸣器发声
- 重复以上流程

**接着我们来看，如何用代码来实现上面的想法**

51单片机提供了汇编语言给开发者使用，也就是我们常说的机器码

每行机器码最终会被加载到指令寄存器，然后由译码器解析执行，如果瞎几把写，格式不对可是无法运行的哦

现在有这么个问题，汇编是可以写，但是，51的整个指令系统有42种助记符和111种指令，写出来的代码丝毫没有可读性

所以，我们可以选择用 C 语言，来开发这个需求，然后交给编译器，让编译器把 C 语言编译成目标平台（80C51）的汇编代码

这样，我们就不需要记这些和**平台相关**的汇编代码了


#### 代码实现

实现部分非常简单，hello world 水平，一起来看

```
public void main(){
    while(1){
        allLed = 1; // 让所有的灯都亮起来
        beep = 1; // 蜂鸣器发声
        delay(1s);
        
        allLed = 0; // 关闭所有led
        beep = 0; // 关闭蜂鸣器
        delay(1s);
    }
}
```


#### 原理剖析

代码写完了，接下来选择要编译的平台，我们使用的是 keil ，build 选项中选择 80C51，然后编译就行了

编译成功后，我们会得到一个 .hex 文件，文件内容是16进制的一行行指令