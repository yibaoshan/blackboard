# Android图形系统（二）驱动层：垂直同步和三级缓冲

写在前面：

本篇文章已经重构完成并掘金发布了，重写的原因是文章通篇堆砌的都是名词解释和自以为有趣的小包袱，毫无逻辑可言

这篇文章留着自省，记录自己成长的过程



对于应用开发工程师来说，虽然我们不需要写驱动程序，但是了解View最终是如何显示到屏幕上还是非常有必要的

本篇是Android图形系列的第二篇文章，依旧是一些关于屏幕的名词解释，和Android系统本身没有太大关系，相较于第一篇文章，本篇重点在于介绍“屏幕刷新机制”相关的知识点



**“屏幕刷新”涉及到许多技术名词：逐行扫描、隔行扫描、刷新率、帧率、画面撕裂、垂直同步信号、双重缓存、三重缓冲等等，单独去了解其中的某一个词可能会觉得很容易理解，但将它们组合在一起时，情况可能就会变得复杂一些**

比如：

> **帧率与刷新率的区别，帧率是不是一定要和刷新率匹配，不匹配时多出来的帧率是不是浪费了？**
>
> **垂直同步信号的出现是为了解决什么问题？**
>
> **为什么电脑开启了垂直同步后感觉更卡了？**
>
> **有的应用在60HZ屏幕体验很好，反而在120HZ屏幕上却出现卡顿，为什么？**
>
> **既然刷新率越高体验越好，那厂商干嘛不直接出10000HZ的屏幕？**
>
> **...**

本篇文章将会带着大家一起去寻找这些问题的答案

前排提示：

> - **为了更好的理解每项技术诞生的背景，强烈建议按照文章的顺序进行阅读**
> - **文章不涉及代码，非技术人员可以放心食用**

![image_android_view_v2_overview](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_overview.jpg)



## **一、开篇**

手机屏幕发展至今，市场上在售手机的屏幕类型基本可以分为两种：**LCD屏和OLED屏**

其实不只是手机屏幕，**电脑**和**电视**屏幕面板基本也就这两种

早在LCD屏和OLED屏诞生之前，我们使用的显示器大多都是CRT显示器

![image_android_view_v2_crt_overview](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_crt_overview.gif)

*图片来源：https://gfycat.com/courageousunhealthyirishdraughthorse-computing-recycling-backlit-cathode*

如图所示，这种带着大屁股电脑就是**CRT显示器**，小时候家里的**大屁股彩电**、街机厅里面的**街机**也都是CRT显示器的一种

屏幕刷新中的**“逐行刷新”**技术是来源于**CRT显示器**，为了后续的剧情能够正常发展，在正文开始前我们需要先来了解一下这个快被遗忘的老家伙

### **显示器的鼻祖：CRT**

**CRT显示器**学名为**“阴极射线显像管”**，是一种使用阴极射线管（Cathode Ray Tube）的显示器，主要有五部分组成：**电子枪**、偏**转线圈**、**荫罩**、**高压石墨电极**和**荧光粉涂层**

![image_android_view_v2_crt_dismantle](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_crt_dismantle.jpg)

*图片来源：[《计算机图形学基础（第3版）》](https://www.amazon.cn/dp/B07R4LNRR6)*

> [多扫描线彩色crt显像管及多扫描线高清crt图像显示装置：](https://patents.google.com/patent/CN1877782A/zh)
>
> **CRT(Cathode Ray Tube)阴极射线显像管**是一种采用多扫描线彩色CRT显像管实现高清晰度图像显示的装置的应用技术，以及一种多扫描线彩色CRT显像管多组电子束扫描矫正的调整方法
>
> 通过对图像信号进行数字技术处理，以及多扫描线彩色**CRT显像管**的采用，使**CRT显像管**能够实现大屏幕、高亮度、高对比度、高清晰度等性能，以适应HDTV高清晰度数字电视机以及高清晰度图像显示器的技术要求
>
> 一般的**CRT显示器**，如：**CRT电视机**和**CRT电脑显示器**，目前使用的**CRT显像管**都是属于单扫描线CRT显像管
>
> **CRT显像管**是靠电子枪发射电子束轰击荧光粉而发光的，荧光粉发光响应速度快，色彩鲜艳，对比度高，这些优点是其它显示器难以比得及的
>
> 但**CRT显像管**显示器与其它平板显示器相比，也有缺点：**显示器的屏幕越大，屏幕发光亮度和对比度就越低**，因此，目前一般**CRT显像管**显示器的最大屏幕尺寸很难做到32寸以上

**简单来说，CRT屏幕之所以能够显示图像，是靠电子枪发射的电子束来点亮的荧光粉实现的**

我们知道了CRT的显示原理，加上在图形系列的第一篇文章中介绍的**LCD液晶屏**和**OLED屏**，我们就有三种不同类型的显示器屏幕了

**CRT**的显示原理刚刚解释过了，另外两种我们一起来回顾一下：

> - **LCD是液晶面板，通过控制液晶层电压就可以改变像素颜色**
> - **OLED是自发光二极管，控制单个二极管的电流就可以改变像素颜色**

关于CRT屏幕的补充到这就结束了，接下来开始今天的正文：**显示器屏幕是如何刷新的？**

## **二、屏幕刷新原理**

上一小节我们知道了CRT是由电子束轰击点亮荧光粉来显示图形的，而荧光粉的特性就是被点亮后很快就会熄灭了，所以电子枪需要一刻不停的扫描

**那CRT屏幕刷新原理就显而易见了：电子枪快速扫描**

### **1、CRT刷新机制：快速扫描**

电子枪使用的扫描方式有很多，比如直线式扫描，圆形扫描，螺旋扫描等等，我们今天要介绍的是直线式扫描中的“逐行扫描”和“隔行扫描”

- **逐行扫描**

> 逐行扫描是最原始的扫描方式，电视机诞生之初使用的就是逐行扫描
>
> 逐行扫描的意思很简单：在一块CRT的屏幕上，电子枪按照从左到右、从上到下的顺序移动发射电子束的方式就叫做逐行扫描

- **隔行扫描**

> 隔行扫描是在逐行扫描的基础上修改的，扫描的顺序依旧是从左到右、从上到下，只是把原来一行行向下扫描改成了隔一行扫描一行

![image_android_view_v2_crt_scan](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_crt_scan.gif)

如图所示，隔行扫描第一次会先扫描奇数行，第二次会扫描偶数行，两次扫描结束后才是一幅完整的图形

**隔行扫描得到的视频质量是不如逐行扫描的视频的，相比之下，隔行扫描图像的清晰度要差一些，而且还会伴有轻微的闪烁**

**这里可能有同学要问：既然隔行扫描的质量不如逐行扫描，那为什么还要发明它呢？**

**答：因为市场有需求**

- **隔行扫描的诞生背景**

> 早期的广播电视播放内容比较单一，大部分是文字广告和音乐之类的内容，电影还是使用“电影放映机”来播放的
>
> 电视机发明后，人们想把电影节目也搬到电视节目当中，但是当时的**广播电视传输带宽不够**，所以人们就想了个办法：将一幅画面的数据按照奇偶数拆成两场，其中奇数行称为上场，偶数行称为下场，分成**两次传输**
>
> 电视机每次接收到的也是半幅画面，在PAL制式和NTSC制式中，显示器接受到数据后会先显示奇数行，再显示偶数行，两次显示后凑成一幅完整的图像
>
> 再后来，DVD被发明出来，相当于电视机播放的是本地视频，广播传输的带宽不再是瓶颈，所以后来的CRT电视机逐行和隔行都支持，我们小的时候看的大屁股电视，只要带有DVD接口的都是可以兼容两种不同的扫描方式的



### **2、LCD/OLED：大人 时代变了**

时间来到了1968年，第一块LCD液晶屏横空出世了

经过了36年的发展，在2004年年末爆发了液晶电视革命，LCD液晶屏幕在亮度、色域、可视角度等各种参数上都完虐老大哥CRT；和液晶屏幕比，CRT屏幕除了在刷新率上有优势外，其他方面都是弟弟

于是乎从2005年开始，夏普、松下、三菱等各大屏幕厂商都陆续宣布停产CRT显示器

2012年，随着最后一家CRT显示器厂家**彩虹电子**宣布停产，CRT时代彻底宣告落幕

..

扯远了，说回液晶屏刷新的事儿

- **驱动原理：有源驱动**

> 首先我们得知道，LCD液晶屏和OLED屏的背后都是有电路板的，那想要控制每个像素点发光显示，就需要有驱动
>
> 驱动又分为两种，一种是**无源驱动**，是指在N*N的像素矩阵由水平垂直两根线来驱动，点亮像素只需要找到它在XY的坐标轴即可，缺点是不能持续的给每个像素通电，只能通过高频的点亮/熄灭像素来维持画面，和之前介绍的PWM调光原理类似
>
> 另一种叫**有源驱动**，TFT-LCD和OLED阵营的AMOLED屏都是属于有源驱动的方式，有源驱动简单来说是在每个像素点后面加入可以单独控制发光的开关，这样每个像素点就可以单独控制了，这样做的好处也显而易见，每个像素都可以持续发光

我在网上没有查到无源驱动和有源驱动各自的市场占用率，我们常见的LCD液晶屏中的**TFT-LCD屏**，和OLED屏的**AMOLED屏**都是使用**有源驱动**的方式，所以接下来关于屏幕刷新的所有都是建立在**有源驱动**之上，也叫**有源矩阵**

- **LCD液晶屏刷新原理**

> 前面介绍了LCD屏幕的大多使用有源驱动的方式，因为有电路驱动的原因，使得屏幕上每个像素点都可以直接寻址，无需等待电子光束到来才能更新
>
> **那是不是可以理解成LCD不需要逐行扫描技术了呢？**
>
> 答案是：NO
>
> **虽然LCD屏幕可以直接寻址来更新像素点，但随着屏幕分辨率越来越高，一次性更新所有像素点的代价也变得越高**
>
> 我们来看一下屏幕驱动从显存读取数据并显示到屏幕这个过程
>
> ![image_android_view_v2_lcd_ddram](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_lcd_ddram.png)
>
> *图片来源：[《理解 LCD 屏幕的驱动原理与调试过程》](https://www.cnblogs.com/juwan/p/13069102.html)*
>
> 看上图，我们重点关注“显示内存（DDRAM）”这个词儿，后续简称显存
>
> 显存里面保存是一幅画面的帧数据，显示控制驱动每次会以一行或者多行的方式读取数据，接着去刷新屏幕像素
>
> 刷新完一帧后驱动便会进入等待状态，等待时间通常是由屏幕刷新率决定的，如果是60HZ，那等到16ms之后驱动再次开始工作

- **OLED屏刷新原理**

  > OLED的显示原理虽然比LCD液晶屏要先进一些，但是在刷新方式上和LCD基本上相同，都是**有源驱动**的方式，所以直接参考LCD液晶屏刷新原理就可以了



### 3、如何才能看到屏幕刷新的过程？

讲了这么多，可不可以观察到屏幕刷新的过程呢？感受一下显示器是如何点亮一个个像素点的？

**可以！**

YouTube上有个专门拍摄慢动作的团队：[The Slow Mo Guys](https://www.youtube.com/user/theslowmoguys)

他们在2018年发布一个叫《[How a TV Works in Slow Motion - The Slow Mo Guys](https://www.youtube.com/watch?v=3BJU2drrtCM)》的视频，视频内容就是介绍不同屏幕类型的电视在高速摄像机里是什么样子的，我截几张图大家感受一下：

![image_android_view_v2_slow_crt](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_slow_crt.gif)

**CRT的逐行刷新，从动图里就能很明显的看到扫描枪的扫描线按照从左到右，从上到下的顺序扫描更新**

![image_android_view_v2_slow_lcd_tv](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_slow_lcd_tv.gif)

**LCD液晶电视的截图，动图里看起来像是整副画面一起更新，实际上我用PR放慢来看是多行像素一起更新**

![image_android_view_v2_slow_lcd_phone](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_slow_lcd_phone.gif)

**动图里是使用LCD液晶屏的iPhone 7手机，原视频太小了看起来很模糊，不过依稀还是可以看到屏幕是一行行像素刷新的**

## 三、刷新率和帧率

在了解完不同类型的屏幕刷新原理之后，**“刷新率”**其实就很好理解了：**单位时间内屏幕刷新的次数，就是屏幕刷新率，表示单位为HZ**

比如常见的60HZ屏幕意思就是1s内屏幕会刷新60次

刷新率是什么很好理解，但它不是我们讨论的重点，本章节打算讨论另外两个有趣的问题：

> 1. **刷新率的高低取决于什么？**
> 2. **手机屏幕的刷新率能不能修改？**

### **1、刷新率的高低取决于什么？**

现在的手机屏幕和电脑显示器的刷新率都越来越高，90HZ、120HZ、144HZ等等

在使用这些高刷显示设备时，u1s1，体验是真的会好很多

**既然120HZ设备相较于60HZ的设备体验会上一个台阶，那厂家为啥不把刷新率拉满呢？直接干到10000HZ行不行？**

要搞懂这个问题，我们需要了解是什么决定了刷新率的上限，CRT、LCD、OLED这几种类型的屏幕因为刷新原理的不同，所以要分开说

- **CRT显示器：**

> 对于CRT显示器来说，电子枪按照**从左到右、从上而下**的顺序进行扫描，在扫描完整个屏幕后为一次刷新
>
> 扫描线需要在水平和垂直两个方向移动，电子枪在固定在电视机靠后的位置，控制水平方向的偏转板和垂直方向的偏转板来改变偏转角度，从而使得电子束精确落在指定位置
>
> 那么，在一秒钟内**水平/垂直偏转板移动速度的极限**就是CRT显示器的刷新率上限

- **LCD液晶屏：**

> 对于LCD屏幕来说，**刷新率的上限取决于屏幕的响应时间**
>
> 屏幕上每个像素点都是由红、绿、蓝（RGB）三个子像素组成的，要实现画面色彩的变化，就必须对RGB三个子像素分别做出不同的明暗度的控制
>
> 而改变子像素的明暗度，就是改版出光亮，就需要去控制液晶格栅的翻转角度，所以
>
> 液晶翻转的速度就是LCD显示器的刷新上限，对于LCD来说，这个上限值可能还会波动
>
> 比如在冬天低温环境下，LCD液晶反应就会变慢，屏幕响应时间会变长，所以哪怕只有60HZ的屏幕在冬天也很容易出现拖影的现象
>
> ![image_android_view_v2_lcd_ghosting](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_lcd_ghosting.gif)
>
> *图片来源：https://www.bilibili.com/read/cv4145704*
>
> PS：屏幕响应时间有两个标准，一个是**“黑白响应时间”**，指的是液晶格栅从完全关闭到完全打开的时间，另一个是**“灰阶响应时间”**，指的是像素从颜色A转换到颜色B所需要的时间
>
> 我们平时讨论的屏幕响应时间一般是指**“灰阶响应时间”**

- **OLED屏幕：**

> 对于OLED屏幕来说，刷新率的上限和LCD类似，都是取决于屏幕**“灰阶响应时间”**
>
> 不过由于OLED没有液晶层，每个子像素都是单独发光，所以刷新率上限相对LCD屏幕会更高许多

**总结一下，老式的大屁股刷新率取决于内部的水平/垂直偏转板的移动速度，LCD和OLED取决于屏幕本身的素质**

### **2、如何更改手机屏幕的刷新率？**

手机上使用的屏幕基本上只有LCD和OLED两种类型，既然LCD/OLED的刷新率上限取决于屏幕素质，那手机的刷新率能不能像CPU一样超频使用呢？

**答案是可以的！**

比如我手里Pixel 3就被我超频到61HZ了，它原先只有可怜的60HZ

![image_android_view_v2_pixel_change_hz](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_pixel_change_hz.jpeg)

**屏幕超频的方式多种多样，比如我的手机是使用酷安大佬制作的[“RR屏幕刷新率”](https://www.coolapk.com/apk/com.rise.rr)修改的，小米部分机型可以root后刷文件来修改，三星s20更加粗暴，直接通过adb命令就可以修改掉刷新率**

能够超频的原因我个人猜测是修改了屏幕的配置文件，想要超频自己手机的小伙伴一定要先去[论坛](https://www.akr-developers.com/?q=%E8%B6%85%E9%A2%91)找一下有没有成功的先例

随意超频可能会出现点击偏移、显示卡顿、LCD可能会出现残影等待现象，非常不建议折腾自己的主力机

### **3、什么是帧率？**

聊完了刷新率我们接着说**帧率（Frame Rate）**

我们平时打游戏时除了关注网络延迟外，通常还会关注**FPS**这个指标，**FPS越高游戏画面越流畅**，那到底什么是**帧率**？

![image_android_view_v2_15_30_60fps](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_15_30_60fps.gif)

要解释这个问题，我们需要了解胶卷时代下的胶片电影放映机是如何播放影片的 

![image_android_view_v2_fps_movie](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_fps_movie.gif)

*图片来源：https://www.bilibili.com/video/BV1kE411c7yZ*

电影放映机内部是由高亮度的灯加上不同焦距的放映镜头组成，播放电影时，胶片以每秒456毫米8.0英寸的速度（也就是24 fps）穿过投影机，最终投射到幕布上，通过切换不同的胶卷来展示连续移动的画面

**每分钟展示的胶片数量，就是帧率，简单来说就是源文件的速率**

**有的同学可能要问了：你说的不对，电影在制作的时候帧率就固定了，计算机的画面都是实时渲染的，跟播放电影是两回事啊？**

对，显卡渲染的画面和播放固定帧的电影的确不是同一回事，为了方便理解，我后续会把源文件的类型分为两种：

- **静态源文件**

> 我们在使用DVD、光盘机等设备播放的视频被称为**“静态源文件”**
>
> 此时不考虑设备接口、芯片性能等因素，假设传输的速度和硬件解码性能都是足够的

- **动态源文件**

> 我们在使用计算机时（智能手机也是计算机），不管是办公还是打游戏，对于显示器来说，我们的源文件就是显卡实时渲染的画面，动态画面被称为**“动态源文件”**
>
> *PS：网上没有静态源文件/动态源文件这样的说法，为了方便理解我自己臆想出来的，用静/动态来描述我个人感觉更直观一些，觉得表达有误的可以自己重新想个词儿，理解意思就好*

静态源文件（也就是视频）在制作的时候就帧率就已经确定下来了，是一个固定值

所以我们平时在讨论帧率时，大多数情况下讨论的都是动态源文件，也就是由CPU或者GPU实时渲染出来的画面



## 四、在60HZ屏幕上播放120帧视频，眼睛看到的是60还是120？

刷新率和帧率其中的任何一个单拎出来都很好理解，但是将它俩组合在一起时，情况就会变的更加复杂一些，比如：

> **1、电影通常都是24帧，那它是怎么在我的60HZ的显示器上播放的？同理，在90/120/144HZ是如何播放的？**
>
> **2、我的手机摄像很牛逼，能支持最高120帧录制视频，但是手机的屏幕很拉胯，刷新率只有60HZ，用手机录下来的120FPS视频在60HZ的屏幕上回放时，看到的是120帧还是60帧？**
>
> **3、刚给电脑配了一台刷新率为144HZ的显示器，但是游戏的平均帧率只有30FPS，刷新率和帧率不匹配时显示器会如何处理？**
>
> **4、显卡每秒能生成250帧画面，但是显示器只有90HZ，多出来的160帧画面是不是丢弃了？如果是丢弃了如果是丢弃了岂不是浪费了显卡性能？**

要一次讲清楚这几个问题比较难，我们需要把它们分类处理

**先是问题1和问题2，它俩的共性是都是视频播放，可以放到静态源文件一栏**

**问题3和问题4对应的是实时渲染画面问题，分到动态源文件里去**

我们还可以从帧率和**刷新率**的角度拆分，可以分成**“刷新率大于帧率”**和**“帧率大于刷新率”**的情况

把这几种情况组合总结成下面的表格（*未开启垂直同步和多重缓冲等技术*）：

### **1、静态源文件**

- **Q1：电影通常都是24帧，那它是怎么在我的60HZ的显示器上播放的？同理，在90/120/144HZ是如何播放的？**

  > Q1对应的是：刷新率大于帧率
  >
  > 显示器和视频播放器它俩其实是各忙各的，显示器只管闷头读数据，视屏播放器只管调用CPU或者GPU解码视频，然后写入到缓冲区
  >
  > 如果帧率和刷新率是倍数关系，比如144HZ屏幕播放24帧电影，不考虑传输贷款和解码性能的情况下，每一帧展示的次数是144 / 24 = 6次，你眼中看到的还是24副画面，只不过每一帧被重复刷新了6次而已
  >
  > 如果不是倍数关系，以24帧电影在60HZ的屏幕上播放举例，每一帧重复显示的次数可能是2次也可能是3次，原因看图：
  >
  > ![image_android_view_v2_24_movie_60_screen](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_24_movie_60_screen.jpg)
  >
  > *图片来源：自己画的*
  >
  > 屏幕会以固定的16.67ms去刷新屏幕，也就是去缓冲区读数据，不管这个数据是不是和上次的一样
  >
  > 如果播放器用的是FFmpeg，那在调用av_read_frame()方法读帧数据的间隔就是在41ms左右，接着调用解码器，解析完成后丢到缓冲区，什么时候读数据那是显示器的事

- **Q2：我的手机摄像很牛逼，能支持最高120帧录制视频，但是手机的屏幕很拉胯，刷新率只有60HZ，用手机录下来的120FPS视频在60HZ的屏幕上回放时，看到的是120帧还是60帧？**

> Q2对应的是：帧率大于刷新率
>
> 和Q1的情况刚好相反，在刷新率不足的情况下，原本120帧的视频被拉齐到60帧，剩下的60帧会被抛弃
>
> ![image_android_view_v2_120_movie_60_screen](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_120_movie_60_screen.jpg)
>
> *图片来源：自己画的*

### **2、动态源文件**

- **Q3：刚给电脑配了一台刷新率为144HZ的显示器，但是游戏的平均帧率只有30FPS，刷新率和帧率不匹配时显示器会如何处理？**

  > Q3对应的是：刷新率大于帧率
  >
  > 动态源文件和播放视频最大的区别就是帧率是不固定的，以打游戏举例，不同的游戏场景对应的复杂程度也不同，这就会导致在有限的硬件性能下，产出的帧率是波动的，如下图
  >
  > ![image_android_view_v2_144_screen_dynamic_game](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_144_screen_dynamic_game.jpg)
  >
  > *图片来源：自己画的*
  >
  > 我们要知道，游戏画面和电影视频最大的不同是没有曝光时间，灭有曝光时间也就意味着画面没有动态模糊，没有动态模糊大脑就无法想象接下来的运动方向，所以，一旦画面运动幅度过大，而帧率有跟不上，我们的直观感受就是：卡
  >
  > 我们这一小节的问题是刷新率和帧率不匹配时显示器会如何处理？其实答案在上面已经提过了：显示器不做任何处理，它就是台没得感情的机器，以固定速度从缓冲区读数据然后刷新像素颜色

- **Q4：显卡每秒能生成250帧画面，但是显示器只有90HZ，多出来的160帧画面是不是丢弃了？如果是丢弃了岂不是浪费了显卡性能？**

> Q4对应的是：帧率大于刷新率
>
> ![image_android_view_v2_90_screen_250_game](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_90_screen_250_game.jpg)
>
> *图片来源：自己画的*
>
> 参考Q2，多出来的画面是会被丢弃，至于是不是白白浪费了显卡性能，我觉得至少对于游戏来说，显卡能力显著大于显示器刷新率是有好处的，尤其是FPS游戏
>
> 因为屏幕刷新时拿到的总是最新时刻的画面帧，最新帧同时会包含你的键盘和鼠标的处理事件，反映在游戏画面上就是你会觉得鼠标更跟手了

**综上，不管是播放视频还是打游戏，最终我们看到的画面帧率都是 =  min(刷新率，帧率)**



## 五、垂直同步与三重缓冲

我们在分析屏幕刷新率大于视频的帧率的问题时，提到了显示器和视频播放器的工作时都是各自负责自己的内容：显示器只管闷头读数据，视频播放器只管写数据

**本章我们接着显示器和视频播放器展开聊聊，在计算机中，显示器和显卡之间是如何协同工作的**

![image_android_view_v2_display_gpu](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_display_gpu.jpg)

*图片来源：自己画的*

如上图，系统开机后，显示控制器驱动会按照固定速度读取frame buffer（帧缓存区）的数据显示到屏幕上

操作系统通常是双缓存策略，显示控制器驱动正在读取的是一个帧缓存，我们就叫它前缓存吧

显卡绘制后写入的又是一个帧缓存，我们叫它后缓存吧，显示刷新的过程就不停的切换由前后缓存组成的缓存队列

### **1、什么是画面撕裂？**

交换帧缓存的动作通常是由显卡完成的，在2.2小节我们介绍LCD刷新原理时提到了，显示器并不是一次性更新所有的像素点，而是一行像素或者多行像素一起更新

**那就可能发生正在刷新屏幕像素时，帧缓存区的数据被更改，最终导致显示错乱的情况：**

![image_android_view_v2_tear_top](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_tear_top.GIF)

动图模拟的是显示控制器驱动正在刷新屏幕像素，上半部分的像素已经更新完成，假设屏幕的刷新率是60HZ，那么再次刷新者上半部分的像素点就要等到16ms以后了

**此时如果帧缓存区的数据被更改，显示器依旧会按照当前的偏移量读取数据并刷新，那我们就会看到一个撕裂的画面**

![image_android_view_v2_tear_bottom](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_tear_bottom.GIF)

如图，和上半部分一样，下半部分的像素刷新同样要等到16ms以后，这也是我们能够看到“画面撕裂”的原因

如果之后显卡保持这个频率输出帧，恭喜你，你能在屏幕上看到连续撕裂的画面

### **2、如何解决画面撕裂？**

产生画面撕裂的原因是屏幕刷新率和显卡输出的帧率不匹配，如果显卡能够稳定的输出60帧，那..那也可能会出现画面撕裂，只是每次画面撕裂的都是同一个地方[旺柴]

**画面撕裂的原因有两个，一个是屏幕的问题，刷新率太慢；另一个是显卡的问题，交换fram e buffer的时机不对**

我们分别从屏幕和显卡的角度，看看对应的解决方案

- **方案一**

  > 天下武功 唯快不破！
  >
  > 我们可以买一台刷新率无限大的显示器，让显示控制器驱动一刻不停地从帧缓存区读数据去刷新像素，这样屏幕每时每刻都处在撕裂状态
  >
  > 但是又因为刷新的太快，每行像素在屏幕停留的时间太短，所以人眼根本没有机会观察到画面撕裂

- **方案二**

  > 既然画面撕裂的本质是因为显卡在不恰当的时机交换了帧缓存，那我们让显卡在显示器刷新得这段时间内不触发交换frame butter的动作不就解决问题了
  >
  > **怎么样才能做到呢？**
  >
  > 我们可以让显示控制器驱动在每次刷新屏幕之后，发送完成的信号，显卡接收到完成信号后再进行swap buffer，这个完成的信号，就是大名鼎鼎的VSync（垂直同步）信号
  >
  > ![image_android_view_v2_process_vsync](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_process_vsync.jpg)
  >
  > *图片来源：自己画的*
  >
  > 如图，显示器控制驱动每次刷新完会发送中断信号，显卡那边每次接收到中断信号后才会发起交换帧缓存的动作，这就可以避免发生画面撕裂
  >
  > ps：很多文章和视频都解释画面撕裂因为显卡速度太快导致的，这个说法不严谨，只能说如果帧率明显大于刷新率则会提高看到画面撕裂的概率

好，现在方案有了，我们来看看具体要怎么落地

方案一现阶段实现起来可能会有点困难，因为不管是LCD液晶屏还是OLED屏，颜色转换总归是需要时间的，做不到无限快的速度

方案二看起来是可行的，我们可以建立个行业标准，呼吁每个显示器厂家在研发新的屏幕时，刷新完了让控制驱动向CPU发送一个中断信号（事实上，绝大多数的显示器都已经这么做了），其他的就不用显示器操心了，操作系统会让显卡驱动接收到回调方法的

**事情就这么愉快的结束了吗？NO！**

我们平时在玩游戏时，发现一旦选择开启垂直同步选项，就会觉得游戏画面更卡了，鼠标也不跟手了，这是为什么？

### 3、垂直同步的弊端

开启垂直同步后，显卡总是会等VSync信号到来时才会触发交换帧缓存，这就带来两个问题：

- **1、画面延迟**

> 显卡接收到VSync信号后交换帧缓存，接着才去绘制新的画面，那么在等待垂直同步信号的过程中，我们操作鼠标、键盘的事件虽然被CPU处理了，但因为显卡在阻塞态，没办法立刻渲染出来
>
> 这就导致了我们看到的画面是有延迟的，比如我向右移动了鼠标，屏幕要过一小会会才会显示出来；在日常办公中这点延迟感受不到，但是在玩游戏时这个延迟就能被感知了
>
> 如果是职业玩家以300**APM值**来算，平均每秒会触发5次键鼠事件，他们肯定希望自己的操作能立马呈现到屏幕上
>
> 所以，在玩一些实时性要求很高的游戏时，非常不建议开启垂直同步选项

- **2、显卡锁帧**

> **显卡最高输入帧率被限制到屏幕刷新率，实际帧率 = min(刷新率，帧率)**
>
> 这个很好理解，接收到VSync信号后才去工作，所以输出帧率永远不可能会大于屏幕刷新的次数
>
> 如果运气不好，遇到比较复杂的画面，无法在16ms内完成绘制工作，当下一个垂直同步信号来临时，显卡当前的工作还没有完成，显示器就只能继续读取上一帧的画面了
>
> 所以，在显卡性能较低的电脑上，非常不建议开启垂直同步选项，显卡画张图本来就已经很不容易了，碰巧遇到一张简单的图，费老大力画完了打算给屏幕，结果你让我候着等信号？万一下一帧画面比较复杂，等我花完又不知猴年马月了[旺柴]

**啧啧啧，为了解决画面撕裂又带来的这两个新问题，付出的代价好像有点大，那有没有什么方式能够解决这两个问题呢？**

**有！**

### 4、三重缓冲和自适应刷新

经常跟垂直同步一起出现的另一个词叫做：三重缓存

**有必要提前说明，Triple buffer有好几种定义，我们这里讨论的三重缓存是必须在开启垂直同步的前提下才能使用，目的是尽量减少渲染延迟：**

> 开启垂直同步后画面延迟的原因是只有两个frame buffer，一个在供屏幕使用，另一个则已经写好了数据等待交换
>
> 那我们可以再引入一个frame buffer，就叫buffer 3吧，三个buffer组成队列，队列顶部的buffer 1等待VSync信号到来后和队列中buffer 2进行交换，大致流程如下图：
>
> ![image_android_view_v2_process_triple_buffer](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_process_triple_buffer.jpg)
>
> *图片来源：自己画的*
>
> 显卡这边一直在工作，向buffer 3中写数据，一帧绘制完成后和buffer 2进行交换，这样buffer 2永远都是一副完整的帧数据

开启三重缓存只能减缓渲染延迟，而且哪怕显卡性能很牛逼，输出性能依旧被锁到最高60HZ

**那有没有不锁帧的方法呢？**

**也有！**

我们从上面的流程图可以看到，显示器和显卡的通信时单向的，显卡能够得知屏幕有没有刷新完，但是屏幕不知道显卡的状态

如果你的屏幕如果支持英伟达的**G-Sync技术**或者AMD的**Free Sync技术**，那配合自家的显卡驱动就可以实现双向通信，这样显示器和显卡就可以互通有无了

![image_android_view_v2_process_adaptive](/Users/bob/Desktop/Bob/work/workspace/androidstudio/Blackboard/Blog/src/main/java/com/android/blog/android_view/imgs/second/image_android_view_v2_process_adaptive.jpg)

*图片来源：自己画的*

**G-Sync和Free Sync包括苹果家的ProMotion都是使用双向通信的方案，这样的技术被统称为自适应刷新**



## 六、结语

在文章的结尾，我们来按照标题顺序总结一下本篇文章的内容

- 开篇和第二章节介绍CRT显示器、LCD液晶屏以及OLED屏幕的工作原理，顺便展示了屏幕刷新的过程
- 第三章介绍刷新率和帧率的概念，还讨论了刷新率没办法无限提高的原因
- 第四章依旧是刷新率和帧率相关知识点，重点在于刷新率和帧率不匹配时显示器会如何处理
- 第五章是本篇文章的重点，前几章的内容都是为第五章做铺垫，主要是解释画面撕裂、垂直同步、三重缓冲以及自适应刷新率这几个常见的含义

**Android图形系列的Display部分先写到这，后续有新的认知我再回来补充，接下来我会开始准备图形系列的第三篇，关于Graphics的文章，敬请期待..**

最后，在写文章的过程中我查了非常多的资料，其中有一些我觉得还不错的内容分享给大家，希望这些知识也能够帮助到你

- **关于视频帧率，推荐影视飓风团队在B站的视频：[【硬核科普】奇妙的帧率增加了！](https://www.bilibili.com/video/BV1kE411c7yZ)**

  > Tim的视频是我在文章后期才发现的，视频质量很高。因为我自己会一点摄影和后期，所以在介绍逐行/隔行扫描的章节中加入了拍摄前期和后期导的注意事项
  >
  > 看完了影视飓风的科普节目后，我觉得他们比我讲的要好，并且我也不想涉及太多无关Android技术的内容，所以就把摄像后期相关内容给删了，在这里墙裂推荐爱好摄影的小伙伴去关注影视飓风团队，会让你少踩很多坑.

- **关于显示器刷新率，推荐The Slow Mo Guys团队在YouTube上的视频：[《How a TV Works in Slow Motion？》](https://www.youtube.com/watch?v=3BJU2drrtCM)**

  > 没法科学上网的小伙伴可以去B栈看搬运视频：[【科普】显示屏是如何工作的？](https://www.bilibili.com/video/BV11W411H7Bo)

- **关于垂直同步信号，推荐硬件茶谈在B站的视频：[【硬件科普】全网最详细易懂的G-sync Freesync 垂直同步工作原理科普](https://www.bilibili.com/video/BV1FK4y1x7bk)**

  > 视频制作的挺不错的，但有几处比较明显的错误，比如LCD液晶屏上的逐行刷新起码是一次更新一行像素，而不是和CRT的逐行刷新类似
  >
  > 所以大家看完视频后一定要记得看评论修正偏差，尤其是ID叫做[xman12346](https://space.bilibili.com/272833187)大佬的发言，一定要看

- **关于iOS高刷屏的优化，推荐字节跳动团队在掘金发布的文章：[《iOS 高刷屏监控 + 优化：从理论到实践全面解析》](https://juejin.cn/post/7074759817738321956)**

- **关于Android高刷原理，推荐Google Android团队在掘金发布的文章：[在 Android 上进行高刷新率渲染](https://juejin.cn/post/6844904163579527181)**

  > Google Android团队日常除了会维护掘金平台外，在微信公众号上也有账号，而且更新频率很高，Android开发者可以去关注一波，了解官方团队最近都在干啥

- **关于Flutter在高刷屏上的应用，推荐恋猫de小郭在掘金发布的文章：[《Flutter 120hz 高刷新率在 Android 和 iOS 上的调研总结》](https://juejin.cn/post/7081273509690736653)**



**全文完**



## 七、参考资料

- [《计算机图形学基础（第3版）》-陆枫, 何云峰 ](https://www.amazon.cn/dp/B07R4LNRR6)
- [《多扫描线彩色crt显像管及多扫描线高清crt图像显示装置》](https://patents.google.com/patent/CN1877782A/zh)
- [《What is V-Sync? Should You Turn it on or off?》](https://www.hardwaretimes.com/what-is-v-sync-should-you-turn-it-on-or-off/)



