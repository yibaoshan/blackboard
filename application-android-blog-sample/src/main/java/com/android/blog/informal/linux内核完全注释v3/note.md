
作为操作系统之心的 Linux 内核涵盖众多领域，如操作系统原理、硬件抽象以及驱动开发等

作为核心组件，内核实现了操作系统的基本功能，如进程调度/管理、内存管理、设备驱动、文件系统等。它是 GNU/Linux 操作系统的核心，确保整个系统的稳定性和性能

Linux 的诞生、发展和成长的过程，依赖于以下 5 个重要的支柱：

- UNIX 操作系统
- MINIX 操作系统
- GNU 计划
- POSIX 标准
- Internet 网络

0.11 版本不包含专门的进程等待队列，TCP / IP 网络等当前非常重要的代码；对内存的分配和使用与现如今的内核也有所区别。

第 20 页描述了，本书包含的 5 个部分的内容，每个章节讲的啥。

## 第二章：微型计算机组成结构

硬件是操作系统运行的基础平台。了解操作系统运行的硬件环境，是深入理解操作系统的必要条件。本章介绍传统微机的组成结构

南桥北桥：

最初的 80386 只有 ISA 总线，系统只能使用 16 位的数据线进行数据传输。

随着计算机的发展，除了 CPU 以外，PC 机的主板主要有两个超大规模的芯片构成：

- 北桥 Northbridge ： 用于管理与 CPU 、内存、AGP 视频接口等高速设备，MCH（Memory Controller Hub）
- 南桥 Southbridge ： 管理 PCI 总线、IDE 硬盘接口、USB 端口等中低速设备，ICH（I/O Controller Hub）

### I/O 端口寻址和控制访问方式

CPU 要访问 I/O 端口的数据，首先需要指定它们的地址。

- 统一编址：把 I/O 控制器的端口地址，纳入内存范围，当做内存处理了。读写指令和读写内存相同
- 独立编址：把 I/O 控制器端口当做独立的地址空间，每一个端口都有一个 I/O 地址对应，并且使用专门的 I/O 指令来访问端口。

IBM PC 主要使用独立编址的方式，部分使用统一编址，比如：

CGA 显示卡的显示内存的地址，就是直接占用了存储器 0xB800 ~ 0xBC00 范围；想要一个字符显示在屏幕上，可以直接使用内存操作指令，往这个内存区域执行 '写' 操作。

I/O 接口数据传输，可以采用：

- 程序循环查询，死循环等待数据，使用和编码都比较简单，就是费 CPU 时间 ，，，
- 中断处理，需要中断控制器支持，CPU 接受到来自 I/O 的中断信号以后，去 Linux 系统写入的描述表查询跳转地址，大多数硬件都是使用中断
- DMA ，用于传输数据的独立芯片，搬砖的，，通常磁盘会使用中断+ DMA 的方式配合操作系统完成数据传输，DMA 传好了中断 CPU 一下下

### 主存储器、BIOS 和 COMS 存储器

如果物理机器有 16MB 的内存，那么在 0.1x 的 Linux 系统当中：

- 0 ~ 640K 用于存放内核代码和数据
- 640K ~ 1M 之间的 384K ，是 BIOS 设置的显示缓存区、中断向量表、ROM 映射区等等
- 1M ~ 16MB 是用于分配的主内存区

基本输入输出系统 Base Input Output System

负责基础的硬件自检，建立操作系统需要的配置表，比如中断向量表，硬盘参数

介绍 CMOS、中断控制器、DMA 控制器、定时器、键盘控制器、串行控制卡、软盘和硬盘控制器

## 第三章：内核编程语言和环境

Linux 0.11 支持两种汇编器，as86 汇编器，GNU 的 gas 汇编器

读本书的目的是了解 Linux 是什么，没有兴趣实现一个操作系统玩玩，本章节略过

## 第四章：80X86 保护模式及其编程

4.1 介绍了 80X86 的系统寄存器和系统指令，包括：标志寄存器、内存管理寄存器、控制寄存器和一些系统级指令。

4.2 章节介绍保护模式的内存管理，比较重要。任何完整的内存管理系统都应该包含两个部分：

- 保护，防止另一个任务（一般指进程）访问到另一个任务或者操作系统的内存区域
- 地址变换，1来可以让操作系统分配内存时更具有灵活性，2来也可以让我们的部分物理内存地址，不被任何逻辑内存地址所映射，可以看做是保护的手段之一。

分段和页表

分段：没怎么看懂，得再查查资料

分页：每页 4 KB，也没怎么看懂

保护模式：

80X86 支持两类保护

1 是可以给不同任务不同的虚拟地址空间，来隔绝两个任务。ps：这不是操作系统的事情吗？和 CPU 有啥关系，不懂

2 是特权级保护，就是常常听说的数字 0 到 3 ，0 是最高级特权 3 是最低

书上说每个内存段都和一个特权级相关联，应用访问某个段的时候，就把当前的特权级和应用的比较一下下

4.3 介绍内存段的定义

80X86 提供了最大 4GB 的物理内存，地址范围从 0 到 0xFFFFFFFF（8个F）

段是虚拟地址到物理地址转换的基础，每个段由 3 个参数定义：

- 段基地址（Base Address）：在物理内存中的起始地址
- 段限长（limit）：这个段的长度
- 段属性（Attributes）：是否可读啊可写啊，段的特权级是啥等

基于以上 3 个属性，80X86 可以做到：

1. 限制程序访问的最大内存偏移量，每个应用只能访问自己段内的 base + limit 大小，超出抛错
2. 应用想向只读段写入内容，会被拒绝

段基，限长，属性等信息在操作系统中被保存在一个叫做，段描述符 Segment Descriptor 的结构体中。

而段描述符又被保存在段表（Descriptor table）的数组里面，在虚拟地址转物理地址的时候会用到这玩意

4.3.2 介绍段描述符表，4.3.3 介绍了段选择符，4.3.4 介绍了段描述符，这几章没看懂，一时分不清是在介绍 OS 还是 CPU 

page 103
