
- Android 14 使用 Linux 5.4 版本作为内核系统，来源：https://mp.weixin.qq.com/s/2hCqWZRrmCYYmDPAMutr3A

# Linux v0.11 

## 题外话（Intel 8086 16 位 CPU 恶心的内存分段机制）

我们知道，Intel 8086 是 16 位的 CPU，即内部的三大总线（地址总线、数据总线、控制总线）都是 16 位的。

那么：

- 控制总线最多支持 2^16 = 65535 种指令。
- 数据总线单次最大传输 65535 个比特。
- 地址总线能够访问的内存范围是 0~65535，即最大支持 64K 内存。

可能是因为当时（1970 ~ 1980）微处理器竞争很激烈（Honeywell、美国国家半导体、AMD、摩托罗拉等都陆续介入了微处理器领域），Intel 可能不满足辛辛苦苦造出来的 CPU 支持的最大内存才 64K。也可能是因为 xxx

总之，Intel 给 8086 造了 20 根地址引脚，这表示 8086 对外输出的最大寻址空间达到了 2^20 = 1048576 bit = 1024 kb = 1mb。

这就给我们编程带来了一个小麻烦，访问内存时

```
mov ax,[xxxx]
```

CPU 工作时，地址总线只是用来传输地址，对这个地址是读还是写，由控制总线控制，所以，地址传输是单向输出的。 8086 内部地址总线是 16 位，外部总线是 20 位，那么问题来了

我是个工程师，现在已知当前板子上连接了 1MB 的内存，那我怎样才能访问到超过 65536 的部分？毕竟，

## 内存的划分

主内存的分配，BIOS 中

```
// linux/init/main.c

static long memory_end = 0;
static long buffer_memory_end = 0;
static long main_memory_start = 0;
```

